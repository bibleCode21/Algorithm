<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HashTable (해시 테이블)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>HashTable (해시 테이블)</h1>

        <h2>개요</h2>
        <p>해시 테이블은 키-값 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 키를 인덱스로 변환하여 빠른 검색을 가능하게 합니다.</p>

        <h2>파일 구조</h2>
        <ul>
            <li><code>HashTableType.ts</code>: 해시 테이블 클래스 구현 (SimpleHashTable, HashTable)</li>
            <li><code>hashTable.ts</code>: 해시 테이블 사용 예제</li>
        </ul>

        <h2>상세 해설</h2>

        <h3>HashTableType.ts</h3>

        <h4>1. SimpleHashTable 클래스</h4>
        <pre><code>export class SimpleHashTable {
    private table: Array&lt;[string, any]&gt;;
    private size: number;
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>충돌 처리가 없는 간단한 해시 테이블</li>
            <li>같은 해시값이 나오면 덮어쓰기 발생</li>
            <li>빠르지만 데이터 손실 가능성</li>
        </ul>
        <p><strong>주요 메서드</strong>:</p>
        <ul>
            <li><code>getKey(data: string)</code>: SHA-256 해시 함수로 키 생성</li>
            <li><code>hash(key: string)</code>: 해시값을 테이블 크기로 나눈 나머지</li>
            <li><code>set(key, value)</code>: 키-값 쌍 저장</li>
            <li><code>get(key)</code>: 키로 값 검색</li>
        </ul>

        <h4>2. HashTable 클래스 (충돌 처리 포함)</h4>
        <pre><code>export class HashTable {
    private table: Array&lt;Array&lt;[string, any]&gt;&gt;;
    private size: number;
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>체이닝(Chaining) 방식으로 충돌 처리</li>
            <li>같은 해시값에 대해 배열로 여러 키-값 쌍 저장</li>
            <li>데이터 손실 없음</li>
        </ul>
        <p><strong>주요 메서드</strong>:</p>
        <ul>
            <li><code>save(key, value)</code>: 키-값 쌍 저장 (충돌 시 체이닝)</li>
            <li><code>read(key)</code>: 키로 값 검색</li>
        </ul>

        <h3>save 함수 상세 분석</h3>
        <pre><code>save(key: string, value: string): void {
    const index = this.hash(key);

    if (this.table[index] !== undefined) {
        for (let i = 0; i &lt; this.table[index].length; i++) {
            if (this.table[index][i][0] === key) {
                this.table[index][i][1] = value;
                return;
            }
        }
        this.table[index].push([key, value]);
    } else {
        this.table[index] = [[key, value]];
    }
}</code></pre>

        <h4>데이터 구조 이해</h4>
        <p><strong>HashTable의 내부 구조</strong>:</p>
        <pre><code>private table: Array&lt;Array&lt;[string, any]&gt;&gt;;</code></pre>
        <ul>
            <li><code>this.table</code>: 전체 해시 테이블 (1차원 배열)</li>
            <li><code>this.table[index]</code>: 특정 인덱스의 체이닝 배열 (2차원 배열)</li>
            <li><code>this.table[index][i]</code>: 체이닝 배열의 i번째 키-값 쌍 (튜플)</li>
            <li><code>this.table[index][i][0]</code>: 키 (문자열)</li>
            <li><code>this.table[index][i][1]</code>: 값 (any 타입)</li>
        </ul>
        <p><strong>예시 데이터 구조</strong>:</p>
        <pre><code>this.table = [
    undefined,                    // index 0: 비어있음
    [["key1", "value1"], ["key2", "value2"]],  // index 1: 2개 키-값 쌍 체이닝
    [["key3", "value3"]],        // index 2: 1개 키-값 쌍
    undefined                     // index 3: 비어있음
]</code></pre>

        <h4>단계별 상세 분석</h4>
        <p><strong>1단계: 해시 인덱스 계산</strong></p>
        <pre><code>const index = this.hash(key);</code></pre>
        <ul>
            <li><code>key</code>를 SHA-256 해시 함수로 변환 후 테이블 크기로 나눈 나머지</li>
            <li>예: <code>key = "apple"</code> → <code>hash("apple") = 12345</code> → <code>index = 12345 % 4 = 1</code></li>
            <li>결과: <code>index = 1</code> (테이블의 1번 인덱스에 저장할 예정)</li>
        </ul>
        <p><strong>2단계: 기존 데이터 존재 여부 확인</strong></p>
        <pre><code>if (this.table[index] !== undefined) {</code></pre>
        <ul>
            <li><code>this.table[1]</code>이 <code>undefined</code>인지 확인</li>
            <li><code>undefined</code>: 해당 인덱스에 아무 데이터도 없음 (첫 번째 저장)</li>
            <li><code>Array</code>: 해당 인덱스에 이미 체이닝된 배열이 존재 (충돌 발생)</li>
        </ul>
        <p><strong>3단계: 중복 키 검사 (기존 데이터가 있을 때)</strong></p>
        <pre><code>for (let i = 0; i &lt; this.table[index].length; i++) {
    if (this.table[index][i][0] === key) {
        this.table[index][i][1] = value;
        return;
    }
}</code></pre>
        <p><strong>상세 설명</strong>:</p>
        <ul>
            <li><code>this.table[index].length</code>: 체이닝 배열의 길이 (저장된 키-값 쌍의 개수)</li>
            <li><code>this.table[index][i][0]</code>: i번째 위치의 키</li>
            <li><code>this.table[index][i][1]</code>: i번째 위치의 값</li>
            <li><strong>목적</strong>: 같은 키가 이미 저장되어 있는지 확인</li>
            <li><strong>발견 시</strong>: 기존 값만 업데이트하고 함수 종료 (<code>return</code>)</li>
        </ul>
        <p><strong>예시</strong>:</p>
        <pre><code>// this.table[1] = [["apple", "red"], ["banana", "yellow"]]
// key = "apple", value = "green" 저장 시도

// i=0: this.table[1][0][0] = "apple" === "apple" ✓ (일치!)
// this.table[1][0][1] = "green"으로 업데이트
// return으로 함수 종료</code></pre>
        <p><strong>4단계: 새 데이터 추가</strong></p>
        <p><strong>케이스 A: 중복 키가 없을 때 (체이닝 추가)</strong></p>
        <pre><code>this.table[index].push([key, value]);</code></pre>
        <ul>
            <li><strong>왜 push를 사용하는가?</strong>:
                <ul>
                    <li>같은 해시값을 가진 다른 키들이 이미 존재</li>
                    <li>기존 데이터를 유지하면서 새 키-값 쌍을 추가해야 함</li>
                    <li><code>push()</code>는 배열 끝에 새 요소를 추가하는 메서드</li>
                </ul>
            </li>
        </ul>
        <p><strong>예시</strong>:</p>
        <pre><code>// this.table[1] = [["apple", "red"]]
// key = "banana", value = "yellow" 저장 시도
// "banana"는 기존에 없으므로 push 실행
// 결과: this.table[1] = [["apple", "red"], ["banana", "yellow"]]</code></pre>
        <p><strong>케이스 B: 해당 인덱스가 완전히 비어있을 때</strong></p>
        <pre><code>this.table[index] = [[key, value]];</code></pre>
        <ul>
            <li><strong>왜 새 배열을 생성하는가?</strong>:
                <ul>
                    <li><code>this.table[index]</code>가 <code>undefined</code>이므로 배열이 존재하지 않음</li>
                    <li>첫 번째 키-값 쌍을 저장하기 위해 새 배열 생성</li>
                    <li><code>[[key, value]]</code>: 배열 안에 튜플을 담은 배열</li>
                </ul>
            </li>
        </ul>
        <p><strong>예시</strong>:</p>
        <pre><code>// this.table[2] = undefined
// key = "cherry", value = "red" 저장 시도
// 새 배열 생성: this.table[2] = [["cherry", "red"]]</code></pre>

        <h4>충돌 처리 메커니즘</h4>
        <p><strong>해시 충돌이란?</strong></p>
        <ul>
            <li>서로 다른 키가 같은 해시값을 가지는 경우</li>
            <li>예: <code>hash("apple") = 1</code>, <code>hash("orange") = 1</code> (둘 다 인덱스 1)</li>
        </ul>
        <p><strong>체이닝 방식의 동작</strong>:</p>
        <pre><code>인덱스 1: [["apple", "red"], ["orange", "orange"]]
         ↑                    ↑
    첫 번째 키-값 쌍      두 번째 키-값 쌍 (충돌로 인한 추가)</code></pre>
        <p><strong>왜 이런 구조가 필요한가?</strong></p>
        <ol>
            <li><strong>데이터 보존</strong>: 충돌이 발생해도 모든 키-값 쌍을 잃지 않음</li>
            <li><strong>확장성</strong>: 같은 해시값을 가진 키가 몇 개든 저장 가능</li>
            <li><strong>검색 정확성</strong>: 정확한 키를 찾기 위해 체이닝 배열을 순회</li>
        </ol>

        <h4>시간복잡도 상세 분석</h4>
        <p><strong>평균 케이스 O(1)</strong>:</p>
        <ul>
            <li>좋은 해시 함수로 인해 충돌이 적음</li>
            <li>대부분의 경우 체이닝 배열 길이가 1 또는 매우 짧음</li>
            <li>중복 키 검사 루프가 거의 실행되지 않음</li>
        </ul>
        <p><strong>최악 케이스 O(n)</strong>:</p>
        <ul>
            <li>모든 키가 같은 해시값을 가짐</li>
            <li>체이닝 배열 길이가 n (저장된 모든 키의 개수)</li>
            <li>중복 키 검사를 위해 전체 배열을 순회해야 함</li>
        </ul>
        <p><strong>예시</strong>:</p>
        <pre><code>// 최악의 경우
hashTable.save("a", "1");    // index 0: [["a", "1"]]
hashTable.save("b", "2");    // index 0: [["a", "1"], ["b", "2"]]
hashTable.save("c", "3");    // index 0: [["a", "1"], ["b", "2"], ["c", "3"]]
// "d" 저장 시: 체이닝 배열 3개 요소를 모두 검사해야 함</code></pre>

        <h3>hashTable.ts</h3>

        <h4>사용 예제</h4>
        <pre><code>// SimpleHashTable 사용
const simpleHashTable = new SimpleHashTable(3);
simpleHashTable.set('Andy', '0001111222');
simpleHashTable.set('Dave', '1112222333');
simpleHashTable.set('Trump', '2223333444');

// HashTable 사용 (충돌 처리)
const hashTable = new HashTable(3);
hashTable.save('Dd', '010000000222');
hashTable.save('Db', '010000000333');</code></pre>

        <h2>해시 함수 분석</h2>

        <h3>SHA-256 해시 함수</h3>
        <pre><code>getKey(data: string): number {
    const hash = crypto.createHash('sha256');
    hash.update(data);
    const hexDig = hash.digest('hex');
    return parseInt(hexDig, 16);
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>암호학적으로 안전한 해시 함수</li>
            <li>256비트(64자리 16진수) 출력</li>
            <li>균등 분포로 좋은 해시 성능</li>
        </ul>

        <h3>해시 인덱스 계산</h3>
        <pre><code>hash(key: string): number {
    return this.getKey(key) % this.size;
}</code></pre>
        <p><strong>원리</strong>:</p>
        <ul>
            <li>해시값을 테이블 크기로 나눈 나머지</li>
            <li>0 ~ (size-1) 범위의 인덱스 생성</li>
        </ul>

        <h2>충돌 처리 방식</h2>

        <h3>1. SimpleHashTable (충돌 무시)</h3>
        <ul>
            <li>같은 해시값이 나오면 이전 값 덮어쓰기</li>
            <li>빠르지만 데이터 손실 가능</li>
        </ul>

        <h3>2. HashTable (체이닝)</h3>
        <ul>
            <li>같은 해시값에 대해 배열로 여러 키-값 쌍 저장</li>
            <li>충돌 시 배열에 추가</li>
            <li>검색 시 배열을 순회하여 키 찾기</li>
        </ul>

        <h2>시간복잡도</h2>

        <h3>평균 케이스 (좋은 해시 함수)</h3>
        <ul>
            <li><strong>삽입</strong>: O(1)</li>
            <li><strong>검색</strong>: O(1)</li>
            <li><strong>삭제</strong>: O(1)</li>
        </ul>

        <h3>최악 케이스 (모든 키가 같은 해시값)</h3>
        <ul>
            <li><strong>삽입</strong>: O(n)</li>
            <li><strong>검색</strong>: O(n)</li>
            <li><strong>삭제</strong>: O(n)</li>
        </ul>

        <h2>장단점</h2>

        <h3>장점</h3>
        <ul>
            <li><strong>빠른 검색</strong>: 평균 O(1) 시간복잡도</li>
            <li><strong>유연한 키 타입</strong>: 문자열, 객체 등 다양한 키 사용 가능</li>
            <li><strong>효율적인 메모리 사용</strong>: 필요한 만큼만 사용</li>
        </ul>

        <h3>단점</h3>
        <ul>
            <li><strong>충돌 문제</strong>: 해시 함수 품질에 따라 성능 저하</li>
            <li><strong>순서 없음</strong>: 키의 순서가 보장되지 않음</li>
            <li><strong>메모리 오버헤드</strong>: 해시 함수 계산 비용</li>
        </ul>

        <h2>활용 사례</h2>
        <ul>
            <li>데이터베이스 인덱싱</li>
            <li>캐시 시스템</li>
            <li>프로그래밍 언어의 객체/딕셔너리</li>
            <li>중복 제거</li>
            <li>빠른 검색이 필요한 모든 상황</li>
        </ul>
    </div>
</body>
</html>

