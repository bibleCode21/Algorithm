<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap (힙)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Heap (힙)</h1>

        <h2>개요</h2>
        <p>힙은 완전 이진 트리 기반의 자료구조로, 부모 노드가 자식 노드보다 항상 크거나 작은 특성을 가집니다. 주로 우선순위 큐 구현에 사용됩니다.</p>

        <h2>파일 구조</h2>
        <ul>
            <li><code>HeapType.ts</code>: 최대 힙(Max Heap) 구현</li>
            <li><code>Heap.ts</code>: 힙 사용 예제</li>
        </ul>

        <h2>상세 해설</h2>

        <h3>HeapType.ts</h3>

        <h4>1. Heap 클래스 구조</h4>
        <pre><code>export class Heap {
    heap: number[];
    
    constructor() {
        this.heap = [];
    }
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>배열로 완전 이진 트리 구현</li>
            <li>최대 힙: 부모 노드가 자식 노드보다 큼</li>
            <li>인덱스 관계: <code>parent = Math.floor((i-1)/2)</code>, <code>left = 2*i+1</code>, <code>right = 2*i+2</code></li>
        </ul>

        <h4>2. 삽입 연산 (insert)</h4>
        <pre><code>insert(data: number) {
    this.heap.push(data);
    this.heapifyUp();
}</code></pre>
        <p><strong>과정</strong>:</p>
        <ol>
            <li>배열 끝에 새 요소 추가</li>
            <li><code>heapifyUp()</code> 호출하여 힙 성질 복원</li>
        </ol>

        <h4>3. 힙화 위로 (heapifyUp)</h4>
        <pre><code>heapifyUp() {
    let index = this.heap.length - 1;
    while (index &gt; 0) {
        const parentIndex = Math.floor((index - 1) / 2);
        if (this.heap[index] &gt; this.heap[parentIndex]) {
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        } else {
            break;
        }
    }
}</code></pre>
        <p><strong>동작 원리</strong>:</p>
        <ul>
            <li>새로 추가된 요소를 부모와 비교</li>
            <li>부모보다 크면 교환하고 위로 이동</li>
            <li>부모보다 작으면 중단</li>
        </ul>

        <h4>4. 삭제 연산 (pop)</h4>
        <pre><code>pop() {
    if (this.heap.length === 0) {
        return null;
    }

    const root = this.heap[0];
    this.heap[0] = this.heap[this.heap.length - 1];
    this.heap.pop();
    this.heapifyDown();
    return root;
}</code></pre>
        <p><strong>과정</strong>:</p>
        <ol>
            <li>루트(최대값) 저장</li>
            <li>마지막 요소를 루트로 이동</li>
            <li>마지막 요소 제거</li>
            <li><code>heapifyDown()</code> 호출하여 힙 성질 복원</li>
        </ol>

        <h4>5. 힙화 아래로 (heapifyDown)</h4>
        <pre><code>heapifyDown() {
    let index = 0;
    while (index &lt; this.heap.length) {
        const leftChildIndex = index * 2 + 1;
        const rightChildIndex = index * 2 + 2;

        if (leftChildIndex &gt;= this.heap.length) {
            break;
        }

        const leftChild = this.heap[leftChildIndex] || 0;
        const rightChild = this.heap[rightChildIndex] || 0;

        if (rightChildIndex &gt;= this.heap.length) {
            if (leftChild &gt; this.heap[index]) {
                [this.heap[index], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[index]];
                index = leftChildIndex;
            }
            break;
        }

        if (leftChild &gt; rightChild && leftChild &gt; this.heap[index]) {
            [this.heap[index], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[index]];
            index = leftChildIndex;
        } else if (rightChild &gt; leftChild && rightChild &gt; this.heap[index]) {
            [this.heap[index], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[index]];
            index = rightChildIndex;
        } else {
            break;
        }
    }
}</code></pre>
        <p><strong>heapifyDown의 상세한 동작 원리</strong>:</p>
        <ol>
            <li><strong>초기화</strong>: <code>index = 0</code> (루트 노드부터 시작)</li>
            <li><strong>자식 노드 인덱스 계산</strong>:
                <ul>
                    <li><code>leftChildIndex = index * 2 + 1</code></li>
                    <li><code>rightChildIndex = index * 2 + 2</code></li>
                    <li>이는 완전 이진 트리의 배열 표현에서 자식 노드의 위치를 계산하는 공식</li>
                </ul>
            </li>
            <li><strong>완전 이진 트리 특성 확인</strong>:
                <ul>
                    <li>왼쪽 자식이 존재하지 않으면 (인덱스가 배열 길이보다 크거나 같으면) 리프 노드</li>
                    <li>완전 이진 트리에서는 왼쪽 자식이 없으면 오른쪽 자식도 없음</li>
                    <li>따라서 더 이상 내려갈 곳이 없으므로 종료</li>
                </ul>
            </li>
            <li><strong>자식 노드 값 가져오기</strong>:
                <ul>
                    <li><code>|| 0</code>은 오른쪽 자식이 존재하지 않을 때를 대비한 기본값</li>
                </ul>
            </li>
            <li><strong>오른쪽 자식이 없는 경우 처리</strong>:
                <ul>
                    <li>오른쪽 자식이 없으면 왼쪽 자식과 현재 노드만 비교하면 됨</li>
                    <li>두 자식이 모두 있는 경우와 달리, "더 큰 자식"을 선택할 필요가 없음</li>
                    <li>단순히 왼쪽 자식이 현재 노드보다 크면 교환</li>
                </ul>
            </li>
            <li><strong>두 자식이 모두 있는 경우 처리</strong>:
                <ul>
                    <li><code>leftChild &gt; rightChild</code>: 왼쪽 자식이 오른쪽 자식보다 큼</li>
                    <li><code>leftChild &gt; this.heap[index]</code>: 왼쪽 자식이 현재 노드보다 큼</li>
                    <li><strong>두 조건을 모두 만족해야 교환하는 이유</strong>: 최대 힙에서는 부모가 자식보다 커야 하므로, 현재 노드보다 큰 자식 중에서 가장 큰 자식과 교환해야 함</li>
                </ul>
            </li>
            <li><strong>교환 후 인덱스 업데이트</strong>:
                <ul>
                    <li>교환이 일어나면 <code>index</code>를 해당 자식의 인덱스로 업데이트</li>
                    <li>다음 반복에서 그 위치에서 다시 heapifyDown 수행</li>
                </ul>
            </li>
        </ol>

        <p><strong>시간복잡도가 O(log n)인 이유</strong>:</p>
        <ol>
            <li><strong>트리의 높이</strong>: 완전 이진 트리의 높이는 ⌊log₂(n)⌋ + 1</li>
            <li><strong>최악의 경우</strong>: 루트에서 리프까지 모든 레벨을 거쳐야 함</li>
            <li><strong>각 레벨에서의 작업</strong>:
                <ul>
                    <li>자식 노드 인덱스 계산: O(1)</li>
                    <li>값 비교: O(1)</li>
                    <li>교환: O(1)</li>
                </ul>
            </li>
            <li><strong>총 시간복잡도</strong>: 높이 × 각 레벨의 작업 = O(log n) × O(1) = O(log n)</li>
        </ol>

        <p><strong>예시로 이해하기</strong>:</p>
        <pre><code>힙: [1, 8, 7, 6, 5, 4, 3] (루트가 1로 힙 성질 위반)

1단계: index=0, leftChild=8, rightChild=7
      8 &gt; 7이고 8 &gt; 1이므로 1과 8 교환
      결과: [8, 1, 7, 6, 5, 4, 3]

2단계: index=1, leftChild=6, rightChild=5  
      6 &gt; 5이고 6 &gt; 1이므로 1과 6 교환
      결과: [8, 6, 7, 1, 5, 4, 3]

3단계: index=3, leftChildIndex=7 &gt;= heap.length이므로 종료</code></pre>

        <h3>Heap.ts</h3>

        <h4>사용 예제</h4>
        <pre><code>const heap = new Heap();
heap.insert(15);
heap.insert(10);
heap.insert(8);
heap.insert(5);
heap.insert(4);
heap.insert(20);

console.log(heap.heap);</code></pre>

        <h2>힙의 특징</h2>

        <h3>완전 이진 트리</h3>
        <ul>
            <li>모든 레벨이 채워져 있고 마지막 레벨은 왼쪽부터 채워짐</li>
            <li>배열로 효율적으로 구현 가능</li>
        </ul>

        <h3>힙 성질</h3>
        <ul>
            <li><strong>최대 힙</strong>: 부모 노드 ≥ 자식 노드</li>
            <li><strong>최소 힙</strong>: 부모 노드 ≤ 자식 노드</li>
        </ul>

        <h3>인덱스 관계</h3>
        <ul>
            <li><code>parent(i) = Math.floor((i-1)/2)</code></li>
            <li><code>left(i) = 2*i + 1</code></li>
            <li><code>right(i) = 2*i + 2</code></li>
        </ul>

        <h2>시간복잡도</h2>

        <h3>기본 연산</h3>
        <ul>
            <li><strong>삽입</strong>: O(log n) - heapifyUp</li>
            <li><strong>삭제</strong>: O(log n) - heapifyDown</li>
            <li><strong>최대값 확인</strong>: O(1) - 루트 노드</li>
        </ul>

        <h3>시간복잡도 상세 분석</h3>

        <h4>1. 삽입 연산 O(log n)</h4>
        <ul>
            <li><strong>heapifyUp 과정</strong>: 새로 추가된 요소가 루트까지 올라갈 수 있는 최대 거리</li>
            <li><strong>완전 이진 트리의 높이</strong>: ⌊log₂(n)⌋ + 1</li>
            <li><strong>최악의 경우</strong>: 새 요소가 루트까지 올라가야 함</li>
            <li><strong>각 단계</strong>: 부모와 비교 및 교환 O(1)</li>
            <li><strong>총 시간</strong>: 높이 × 각 단계 = O(log n)</li>
        </ul>

        <h4>2. 삭제 연산 O(log n)</h4>
        <ul>
            <li><strong>heapifyDown 과정</strong>: 루트에서 리프까지 내려갈 수 있는 최대 거리</li>
            <li><strong>완전 이진 트리의 높이</strong>: ⌊log₂(n)⌋ + 1</li>
            <li><strong>최악의 경우</strong>: 루트에서 리프까지 모든 레벨을 거쳐야 함</li>
            <li><strong>각 단계</strong>: 자식들과 비교 및 교환 O(1)</li>
            <li><strong>총 시간</strong>: 높이 × 각 단계 = O(log n)</li>
        </ul>

        <h4>3. 최대값 확인 O(1)</h4>
        <ul>
            <li><strong>이유</strong>: 최대 힙에서 최대값은 항상 루트에 위치</li>
            <li><strong>접근</strong>: 배열의 첫 번째 요소에 직접 접근</li>
            <li><strong>시간</strong>: O(1)</li>
        </ul>

        <h3>힙 생성</h3>
        <ul>
            <li><strong>하향식</strong>: O(n) - 모든 노드를 한 번씩 heapifyDown</li>
            <li><strong>상향식</strong>: O(n log n) - 각 요소를 삽입하며 heapifyUp</li>
        </ul>

        <h4>하향식 힙 생성이 O(n)인 이유</h4>
        <ul>
            <li><strong>직관적 이해</strong>: 대부분의 노드는 트리의 하단에 위치</li>
            <li><strong>heapifyDown 비용</strong>: 높이가 낮은 노드일수록 heapifyDown 비용이 적음</li>
            <li><strong>수학적 증명</strong>:
                <ul>
                    <li>높이 h에 있는 노드 수: ⌈n/2^(h+1)⌉</li>
                    <li>각 노드의 heapifyDown 비용: O(h)</li>
                    <li>총 비용: Σ(h=0 to log n) h × ⌈n/2^(h+1)⌉ = O(n)</li>
                </ul>
            </li>
        </ul>

        <h2>장단점</h2>

        <h3>장점</h3>
        <ul>
            <li><strong>우선순위 큐</strong>: 최대/최소값 빠른 접근</li>
            <li><strong>정렬</strong>: 힙 정렬 구현 가능</li>
            <li><strong>효율적인 삽입/삭제</strong>: O(log n)</li>
        </ul>

        <h3>단점</h3>
        <ul>
            <li><strong>검색 비효율</strong>: 특정 값 검색 시 O(n)</li>
            <li><strong>순서 없음</strong>: 같은 우선순위의 순서 보장 안됨</li>
            <li><strong>메모리 오버헤드</strong>: 완전 이진 트리 구조</li>
        </ul>

        <h2>활용 사례</h2>
        <ul>
            <li>우선순위 큐</li>
            <li>힙 정렬</li>
            <li>다익스트라 알고리즘</li>
            <li>작업 스케줄링</li>
            <li>이벤트 처리 시스템</li>
        </ul>
    </div>
</body>
</html>

