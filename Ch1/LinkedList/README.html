<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LinkedList (연결 리스트)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>LinkedList (연결 리스트)</h1>

        <h2>개요</h2>
        <p>연결 리스트는 노드들이 포인터로 연결된 선형 자료구조입니다. 각 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있습니다.</p>

        <h2>파일 구조</h2>
        <ul>
            <li><code>NodeType.ts</code>: 노드 인터페이스, Node 클래스, NodeManager 클래스</li>
            <li><code>LinkedList1.ts</code>: 기본 연결 리스트 생성 및 순회</li>
            <li><code>LinkedList2.ts</code>: 정렬된 연결 리스트에 노드 삽입</li>
            <li><code>LinkedList3.ts</code>: NodeManager를 사용한 연결 리스트 조작</li>
        </ul>

        <h2>상세 해설</h2>

        <h3>NodeType.ts</h3>

        <h4>1. INode 인터페이스</h4>
        <pre><code>export interface INode {
    data: number;
    prev: INode | null;
    next: INode | null;
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>양방향 연결 리스트를 위한 인터페이스</li>
            <li><code>prev</code>: 이전 노드 포인터</li>
            <li><code>next</code>: 다음 노드 포인터</li>
        </ul>

        <h4>2. Node 클래스</h4>
        <pre><code>export class Node implements INode {
    data: number;
    prev: Node | null;
    next: Node | null;

    constructor(data: number, prev: Node | null = null, next: Node | null = null) {
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>INode 인터페이스 구현</li>
            <li>기본값으로 null 설정</li>
            <li>양방향 연결 지원</li>
        </ul>

        <h4>3. NodeManager 클래스</h4>
        <pre><code>export class NodeManager {
    head: Node | null;
    tail: Node | null;

    constructor(data: number) {
        this.head = new Node(data);
        this.tail = this.head;
    }
}</code></pre>
        <p><strong>주요 메서드들</strong>:</p>

        <p><strong>insert(data: number)</strong>: 끝에 노드 추가</p>
        <pre><code>insert(data: number): void {
    if (!this.head) {
        this.head = new Node(data);
        this.tail = this.head;
        return;
    }

    let node = this.head;
    while (node.next) {
        node = node.next;
    }
    node.next = new Node(data);
    node.next.prev = node;
    this.tail = node.next;
}</code></pre>

        <p><strong>insertBefore(data: number, target: number)</strong>: 특정 값 앞에 삽입</p>
        <pre><code>insertBefore(data: number, target: number): void {
    if (!this.head) {
        this.head = new Node(data);
        this.tail = this.head;
        return;
    }

    let node = this.tail;
    while(node) {
        if (node.data === target) {
            const newNode = new Node(data, node.prev, node);
            if (node.prev) {
                node.prev.next = newNode;
            } else {
                // target이 head인 경우
                this.head = newNode;
            }
            node.prev = newNode;
            break;
        }
        node = node.prev;
    }
}</code></pre>

        <p><strong>delete(data: number)</strong>: 특정 값 삭제</p>
        <pre><code>delete(data: number): void {
    if (!this.head) {
        console.log('해당 값을 가진 노드가 없습니다.');
        return;
    }

    if (this.head.data === data) {
        this.head = this.head.next;
        if (this.head) {
            this.head.prev = null;
        } else {
            this.tail = null;
        }
        return;
    }

    let node = this.head;
    while (node.next) {
        if (node.next.data === data) {
            node.next = node.next.next;
            if (node.next) {
                node.next.prev = node;
            } else {
                this.tail = node;
            }
            return;
        }
        node = node.next;
    }
}</code></pre>

        <p><strong>searchFromHead(data: number)</strong>: 헤드부터 검색</p>
        <pre><code>searchFromHead(data: number): Node | null {
    let node = this.head;
    while (node) {
        if (node.data === data) {
            return node;
        }
        node = node.next;
    }
    return null;
}</code></pre>

        <p><strong>searchFromTail(data: number)</strong>: 테일부터 검색</p>
        <pre><code>searchFromTail(data: number): Node | null {
    let node = this.tail;
    while (node) {
        if (node.data === data) {
            return node;
        }
        node = node.prev;
    }
    return null;
}</code></pre>

        <h3>LinkedList1.ts</h3>

        <h4>기본 연결 리스트 생성 및 순회</h4>
        <pre><code>// 노드 생성 및 연결
const node1 = new Node(1);
const node2 = new Node(2);
node1.next = node2;
let head: Node | null = node1;

// 3부터 9까지 노드 추가
for (let index = 3; index &lt; 10; index++) {
    add(head, index);
}

// 연결 리스트 순회하며 출력
let node: Node | null = head;
while (node && node.next) {
    console.log(node.data);
    node = node.next;
}
if (node) {
    console.log(node.data);
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>수동으로 노드 생성 및 연결</li>
            <li><code>add</code> 함수로 노드 추가</li>
            <li>순회하여 모든 노드 출력</li>
        </ul>

        <h3>LinkedList2.ts</h3>

        <h4>정렬된 연결 리스트에 노드 삽입</h4>
        <pre><code>// 노드 생성 및 연결
const node1 = new Node(1);
const node2 = new Node(2);
node1.next = node2;
let head: Node | null = node1;

for (let index = 3; index &lt; 10; index++) {
    add(head, index);
}

const node3 = new Node(1.5);
while (head && head.next) {
    if (head.data &lt; node3.data && head.next.data &gt; node3.data) {
        node3.next = head.next;
        head.next = node3;
        break;
    }
    head = head.next;
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>정렬된 상태 유지</li>
            <li>적절한 위치에 새 노드 삽입</li>
            <li><code>1.5</code>를 <code>1</code>과 <code>2</code> 사이에 삽입</li>
        </ul>

        <h3>LinkedList3.ts</h3>

        <h4>NodeManager를 사용한 연결 리스트 조작</h4>
        <pre><code>const linkedList1 = new NodeManager(0);
linkedList1.describe();
linkedList1.insert(1);

for (let index = 2; index &lt; 11; index++) {
    linkedList1.insert(index);
}

linkedList1.describe();
console.log(linkedList1.searchFromHead(5));

linkedList1.insertBefore(10, 5);
linkedList1.describe();</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>NodeManager 클래스 활용</li>
            <li>체계적인 연결 리스트 관리</li>
            <li>검색 및 삽입 기능 사용</li>
        </ul>

        <h2>연결 리스트의 특징</h2>

        <h3>장점</h3>
        <ul>
            <li><strong>동적 크기</strong>: 런타임에 크기 조정 가능</li>
            <li><strong>삽입/삭제 효율성</strong>: O(1) (위치가 주어진 경우)</li>
            <li><strong>메모리 효율성</strong>: 필요한 만큼만 사용</li>
        </ul>

        <h3>단점</h3>
        <ul>
            <li><strong>랜덤 접근 불가</strong>: 인덱스로 직접 접근 불가</li>
            <li><strong>메모리 오버헤드</strong>: 포인터 저장 공간 필요</li>
            <li><strong>캐시 비효율성</strong>: 연속된 메모리 공간 아님</li>
        </ul>

        <h2>시간복잡도</h2>

        <h3>기본 연산</h3>
        <ul>
            <li><strong>접근</strong>: O(n) - 순차 접근</li>
            <li><strong>검색</strong>: O(n) - 선형 검색</li>
            <li><strong>삽입 (시작)</strong>: O(1)</li>
            <li><strong>삽입 (끝)</strong>: O(1) - tail 포인터 있으면</li>
            <li><strong>삽입 (중간)</strong>: O(n) - 위치 찾기</li>
            <li><strong>삭제</strong>: O(n) - 위치 찾기</li>
        </ul>

        <h2>연결 리스트 종류</h2>

        <h3>1. 단방향 연결 리스트</h3>
        <ul>
            <li><code>next</code> 포인터만 존재</li>
            <li>메모리 효율적</li>
        </ul>

        <h3>2. 양방향 연결 리스트</h3>
        <ul>
            <li><code>prev</code>, <code>next</code> 포인터 모두 존재</li>
            <li>역방향 순회 가능</li>
        </ul>

        <h3>3. 원형 연결 리스트</h3>
        <ul>
            <li>마지막 노드가 첫 번째 노드 연결</li>
            <li>순환 구조</li>
        </ul>

        <h2>활용 사례</h2>
        <ul>
            <li>LRU 캐시 구현</li>
            <li>브라우저 히스토리</li>
            <li>실행 취소/다시 실행</li>
            <li>다항식 표현</li>
            <li>스택/큐 구현</li>
        </ul>
    </div>
</body>
</html>

