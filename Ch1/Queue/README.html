<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queue (큐)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Queue (큐)</h1>

        <h2>개요</h2>
        <p>큐는 FIFO(First In, First Out) 원칙을 따르는 선형 자료구조입니다. 먼저 들어온 데이터가 먼저 나가는 구조로, 대기열이나 작업 스케줄링에 활용됩니다.</p>

        <h2>파일 구조</h2>
        <ul>
            <li><code>QueueTypes.ts</code>: 큐 관련 인터페이스 정의</li>
            <li><code>Queue.ts</code>: 기본 큐 구현 (FIFO)</li>
            <li><code>PriorityQueue.ts</code>: 우선순위 큐 구현</li>
            <li><code>LIFOQueue.ts</code>: LIFO 큐 구현 (스택과 유사)</li>
            <li><code>example.ts</code>: 다양한 큐 사용 예제</li>
        </ul>

        <h2>상세 해설</h2>

        <h3>QueueTypes.ts</h3>

        <h4>1. PriorityItem 인터페이스</h4>
        <pre><code>export interface PriorityItem&lt;T&gt; {
    value: T;
    priority: number;
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>우선순위 큐에서 사용하는 아이템 구조</li>
            <li><code>value</code>: 실제 데이터</li>
            <li><code>priority</code>: 우선순위 (낮은 숫자가 높은 우선순위)</li>
        </ul>

        <h4>2. IQueue 인터페이스</h4>
        <pre><code>export interface IQueue&lt;T&gt; {
    enqueue(element: T, priority?: number): void;
    dequeue(): T | undefined;
    peek(): T | undefined;
    isEmpty(): boolean;
    size(): number;
    clear(): void;
}</code></pre>
        <p><strong>주요 메서드</strong>:</p>
        <ul>
            <li><code>enqueue</code>: 큐에 요소 추가</li>
            <li><code>dequeue</code>: 큐에서 요소 제거 및 반환</li>
            <li><code>peek</code>: 맨 앞 요소 확인 (제거하지 않음)</li>
            <li><code>isEmpty</code>: 큐가 비어있는지 확인</li>
            <li><code>size</code>: 큐의 크기 반환</li>
            <li><code>clear</code>: 큐 초기화</li>
        </ul>

        <h4>3. IPriorityQueue 인터페이스</h4>
        <pre><code>export interface IPriorityQueue&lt;T&gt; extends IQueue&lt;T&gt; {
    enqueue(value: T, priority: number): void;
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>IQueue를 확장</li>
            <li><code>enqueue</code> 메서드에 우선순위 매개변수 필수</li>
        </ul>

        <h3>Queue.ts</h3>

        <h4>기본 큐 구현 (FIFO)</h4>
        <pre><code>export class Queue&lt;T&gt; implements IQueue&lt;T&gt; {
    private items: T[] = [];

    enqueue(element: T): void {
        this.items.push(element);
    }

    dequeue(): T | undefined {
        return this.items.shift();
    }

    peek(): T | undefined {
        return this.items[0];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }

    clear(): void {
        this.items = [];
    }
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>배열을 사용한 간단한 구현</li>
            <li><code>push()</code>: 배열 끝에 추가 (O(1))</li>
            <li><code>shift()</code>: 배열 앞에서 제거 (O(n) - 비효율적)
                <ul>
                    <li>배열의 첫 번째 요소를 제거하면 나머지 모든 요소를 한 칸씩 앞으로 이동해야 함</li>
                </ul>
            </li>
            <li>실제 프로덕션에서는 연결 리스트 기반 구현 권장</li>
        </ul>

        <h3>PriorityQueue.ts</h3>

        <h4>우선순위 큐 구현</h4>
        <pre><code>export class PriorityQueue&lt;T&gt; implements IPriorityQueue&lt;T&gt; {
    private items: PriorityItem&lt;T&gt;[] = [];

    enqueue(value: T, priority: number): void {
        const item: PriorityItem&lt;T&gt; = { value, priority };
        let added = false;

        for (let i = 0; i &lt; this.items.length; i++) {
            if (item.priority &lt; this.items[i].priority) {
                this.items.splice(i, 0, item);
                added = true;
                break;
            }
        }

        if (!added) {
            this.items.push(item);
        }
    }

    dequeue(): T | undefined {
        return this.items.shift()?.value;
    }

    peek(): T | undefined {
        return this.items[0]?.value;
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }

    clear(): void {
        this.items = [];
    }
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>우선순위에 따라 정렬된 배열 유지</li>
            <li>삽입 시 적절한 위치에 배치 (O(n))</li>
            <li>가장 높은 우선순위(낮은 숫자)가 먼저 나감</li>
            <li>실제로는 힙 기반 구현이 더 효율적</li>
        </ul>

        <h3>LIFOQueue.ts</h3>

        <h4>LIFO 큐 구현 (스택과 유사)</h4>
        <pre><code>export class LIFOQueue&lt;T&gt; implements IQueue&lt;T&gt; {
    private items: T[];

    constructor() {
        this.items = [];
    }

    enqueue(element: T): void {
        this.items.push(element);
    }

    dequeue(): T | undefined {
        return this.items.pop();
    }

    peek(): T | undefined {
        return this.items[this.items.length - 1];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }

    clear(): void {
        this.items = [];
    }
}</code></pre>
        <p><strong>특징</strong>:</p>
        <ul>
            <li>LIFO(Last In, First Out) 원칙</li>
            <li><code>pop()</code>: 배열 끝에서 제거 (O(1))</li>
            <li>스택과 동일한 동작</li>
            <li>큐 인터페이스를 구현하지만 스택처럼 동작</li>
        </ul>

        <h3>example.ts</h3>

        <h4>사용 예제</h4>
        <pre><code>// 기본 큐 사용 예시
const queue = new Queue&lt;string&gt;();
queue.enqueue('apple');
queue.enqueue('banana');

console.log(queue.dequeue()); // apple
console.log(queue.peek()); // banana
console.log(queue.size()); // 1

// 우선순위 큐 사용 예시
const priorityQueue = new PriorityQueue&lt;string&gt;();
priorityQueue.enqueue('중요한 작업', 1);    // 우선순위 1 (가장 높음)
priorityQueue.enqueue('일반 작업', 2);      // 우선순위 2
priorityQueue.enqueue('덜 중요한 작업', 3);  // 우선순위 3 (가장 낮음)

console.log(priorityQueue.dequeue()); // '중요한 작업' (우선순위가 가장 높은 것)
console.log(priorityQueue.peek());    // '일반 작업'
console.log(priorityQueue.size());    // 2</code></pre>

        <h2>큐의 특징</h2>

        <h3>FIFO 원칙</h3>
        <ul>
            <li>먼저 들어온 데이터가 먼저 나감</li>
            <li>대기열과 같은 자연스러운 구조</li>
        </ul>

        <h3>주요 연산</h3>
        <ul>
            <li><strong>Enqueue</strong>: 큐에 요소 추가</li>
            <li><strong>Dequeue</strong>: 큐에서 요소 제거</li>
            <li><strong>Peek/Front</strong>: 맨 앞 요소 확인</li>
        </ul>

        <h2>시간복잡도</h2>

        <h3>배열 기반 구현</h3>
        <ul>
            <li><strong>Enqueue</strong>: O(1) - 배열 끝에 추가</li>
            <li><strong>Dequeue</strong>: O(n) - 배열 앞에서 제거 (shift)
                <ul>
                    <li>첫 번째 요소 제거 후 나머지 모든 요소를 한 칸씩 앞으로 이동</li>
                    <li>배열 크기가 클수록 비효율적</li>
                </ul>
            </li>
            <li><strong>Peek</strong>: O(1) - 첫 번째 요소 접근</li>
        </ul>

        <h3>연결 리스트 기반 구현</h3>
        <ul>
            <li><strong>Enqueue</strong>: O(1) - 끝에 추가</li>
            <li><strong>Dequeue</strong>: O(1) - 앞에서 제거</li>
            <li><strong>Peek</strong>: O(1) - 첫 번째 요소 접근</li>
        </ul>

        <h2>큐의 종류</h2>

        <h3>1. 기본 큐 (FIFO)</h3>
        <ul>
            <li>가장 일반적인 큐</li>
            <li>먼저 들어온 것이 먼저 나감</li>
        </ul>

        <h3>2. 우선순위 큐</h3>
        <ul>
            <li>우선순위에 따라 나가는 순서 결정</li>
            <li>힙 기반 구현이 효율적</li>
        </ul>

        <h3>3. LIFO 큐</h3>
        <ul>
            <li>마지막에 들어온 것이 먼저 나감</li>
            <li>스택과 동일한 동작</li>
        </ul>

        <h3>4. 원형 큐</h3>
        <ul>
            <li>고정 크기 배열 사용</li>
            <li>메모리 효율적</li>
        </ul>

        <h2>장단점</h2>

        <h3>장점</h3>
        <ul>
            <li><strong>단순한 구조</strong>: 이해하기 쉬움</li>
            <li><strong>효율적인 삽입</strong>: O(1) 시간</li>
            <li><strong>자연스러운 대기열</strong>: FIFO 원칙</li>
        </ul>

        <h3>단점</h3>
        <ul>
            <li><strong>제한된 접근</strong>: 중간 요소 접근 불가</li>
            <li><strong>배열 구현의 비효율성</strong>: shift() 연산이 O(n)</li>
            <li><strong>크기 제한</strong>: 일부 구현에서 고정 크기</li>
        </ul>

        <h2>활용 사례</h2>
        <ul>
            <li>작업 스케줄링</li>
            <li>프린터 대기열</li>
            <li>브레드퍼스트 탐색 (BFS)</li>
            <li>이벤트 처리 시스템</li>
            <li>네트워크 패킷 처리</li>
            <li>게임의 턴 기반 시스템</li>
        </ul>
    </div>
</body>
</html>

