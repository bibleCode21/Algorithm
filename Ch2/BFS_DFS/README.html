<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFS and DFS (그래프 탐색 알고리즘)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        hr {
            border: none;
            border-top: 2px solid #e0e0e0;
            margin: 2rem 0;
        }

        a {
            color: #3498db;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
<h1>그래프 탐색 알고리즘: BFS와 DFS</h1>

<h2>개요</h2>

<p>이 폴더는 그래프나 트리를 탐색하는 두 가지 주요 알고리즘인 <strong>너비 우선 탐색(BFS)</strong>과 <strong>깊이 우선 탐색(DFS)</strong>을 구현한 코드를 포함합니다.</p>

<h2>알고리즘 비교</h2>

<table>
<thead>
<tr>
<th>특징</th>
<th>BFS (Breadth-First Search)</th>
<th>DFS (Depth-First Search)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>탐색 방식</strong></td>
<td>레벨별 (너비 우선)</td>
<td>깊이 우선</td>
</tr>
<tr>
<td><strong>자료구조</strong></td>
<td>큐 (Queue) - FIFO</td>
<td>스택 (Stack) - LIFO</td>
</tr>
<tr>
<td><strong>최단 경로</strong></td>
<td>가중치 없는 그래프에서 보장</td>
<td>보장되지 않음</td>
</tr>
<tr>
<td><strong>메모리 사용량</strong></td>
<td>높음 (같은 레벨의 모든 정점 저장)</td>
<td>낮음</td>
</tr>
<tr>
<td><strong>구현 방식</strong></td>
<td>반복문</td>
<td>재귀 또는 반복문</td>
</tr>
<tr>
<td><strong>적합한 상황</strong></td>
<td>최단 경로 찾기, 레벨별 탐색</td>
<td>백트래킹, 깊은 탐색</td>
</tr>
</tbody>
</table>

<hr>

<h1>너비 우선 탐색 (Breadth-First Search, BFS)</h1>

<h2>개요</h2>

<p>너비 우선 탐색(BFS)은 그래프나 트리를 탐색하는 알고리즘으로, 시작 정점에서 가까운 정점들을 우선적으로 방문하는 방식입니다. 큐(Queue) 자료구조를 사용하여 구현됩니다.</p>

<h2>특징</h2>

<ul>
<li><strong>레벨별 탐색</strong>: 같은 레벨의 모든 정점을 먼저 방문한 후 다음 레벨로 이동</li>
<li><strong>최단 경로</strong>: 가중치가 없는 그래프에서 두 정점 간의 최단 경로를 찾을 수 있음</li>
<li><strong>완전 탐색</strong>: 연결된 모든 정점을 방문</li>
<li><strong>큐 사용</strong>: FIFO(First In, First Out) 방식으로 정점을 처리</li>
</ul>

<h2>동작 원리</h2>

<ol>
<li>시작 정점을 큐에 넣고 방문 표시</li>
<li>큐에서 정점을 꺼내고 처리</li>
<li>해당 정점의 모든 이웃을 큐에 추가 (아직 방문하지 않은 경우)</li>
<li>큐가 비어있을 때까지 2-3단계 반복</li>
</ol>

<h2>시간복잡도</h2>

<ul>
<li><strong>시간복잡도</strong>: O(V + E)</li>
<li>V: 정점(Vertex)의 개수</li>
<li>E: 간선(Edge)의 개수</li>
<li><strong>공간복잡도</strong>: O(V)</li>
<li>큐와 방문 배열에 필요한 공간</li>
</ul>

<h2>BFS 구현</h2>

<pre><code>export const bfs = (graph: Graph, start: string) => {
    const result: string[] = [];
    const visited = new Set<string>();
    const queue: string[] = [start];

    while (queue.length > 0) {
        const current = queue.shift()!;
        
        if (!visited.has(current)) {
            visited.add(current);
            result.push(current);
            
            const neighbors = graph.getNeighbors(current);
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    queue.push(neighbor);
                }
            }
        }
    }
    
    return result;
}</code></pre>

<h2>BFS 실행 결과</h2>

<h3>시작점: A</h3>
<pre><code>방문 순서: A -> B -> C -> D -> G -> H -> I -> E -> F -> J</code></pre>

<p><strong>설명:</strong></p>
<ul>
<li>레벨 0: A</li>
<li>레벨 1: B, C (A의 이웃)</li>
<li>레벨 2: D, G, H, I (B, C의 이웃)</li>
<li>레벨 3: E, F, J (D, I의 이웃)</li>
</ul>

<hr>

<h1>깊이 우선 탐색 (Depth-First Search, DFS)</h1>

<h2>개요</h2>

<p>깊이 우선 탐색(DFS)은 그래프나 트리를 탐색하는 알고리즘으로, 한 경로를 끝까지 탐색한 후 다른 경로로 돌아가서 탐색하는 방식입니다. 스택(Stack) 자료구조를 사용하여 구현됩니다.</p>

<h2>특징</h2>

<ul>
<li><strong>깊이 우선</strong>: 한 경로를 끝까지 탐색한 후 백트래킹</li>
<li><strong>메모리 효율적</strong>: 현재 경로만 저장하므로 메모리 사용량이 적음</li>
<li><strong>백트래킹</strong>: 탐색 실패 시 이전 정점으로 돌아가 다른 경로 시도</li>
<li><strong>스택 사용</strong>: LIFO(Last In, First Out) 방식으로 정점을 처리</li>
</ul>

<h2>동작 원리</h2>

<ol>
<li>시작 정점을 스택에 넣고 방문 표시</li>
<li>스택에서 정점을 꺼내고 처리</li>
<li>해당 정점의 모든 이웃을 스택에 추가 (아직 방문하지 않은 경우)</li>
<li>스택이 비어있을 때까지 2-3단계 반복</li>
</ol>

<h2>시간복잡도</h2>

<ul>
<li><strong>시간복잡도</strong>: O(V + E)</li>
<li>V: 정점(Vertex)의 개수</li>
<li>E: 간선(Edge)의 개수</li>
<li><strong>공간복잡도</strong>: O(V)</li>
<li>스택과 방문 배열에 필요한 공간</li>
</ul>

<h2>DFS 구현</h2>

<h3>반복문을 사용한 DFS</h3>

<pre><code>export const dfs = (graph: Graph, start: string): string[] => {
    const result: string[] = [];
    const visited = new Set<string>();
    const stack: string[] = [start];

    while (stack.length > 0) {
        const current = stack.pop()!;

        if (!visited.has(current)) {
            visited.add(current);
            result.push(current);

            const neighbors = graph.getNeighbors(current);
            // 역순으로 추가하여 올바른 방문 순서 보장
            for (let i = neighbors.length - 1; i >= 0; i--) {
                const neighbor = neighbors[i];
                if (!visited.has(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }
    
    return result;
};</code></pre>

<h3>재귀를 사용한 DFS</h3>

<pre><code>export const dfsRecursive = (graph: Graph, start: string): string[] => {
    const result: string[] = [];
    const visited = new Set<string>();

    const dfsHelper = (vertex: string): void => {
        if (visited.has(vertex)) {
            return;
        }

        visited.add(vertex);
        result.push(vertex);

        const neighbors = graph.getNeighbors(vertex);
        for (const neighbor of neighbors) {
            dfsHelper(neighbor);
        }
    };

    dfsHelper(start);
    return result;
};</code></pre>

<h3>경로 찾기 DFS</h3>

<pre><code>export const dfsFindPath = (graph: Graph, start: string, target: string): string[] => {
    const visited = new Set<string>();
    
    const dfsPathHelper = (vertex: string, path: string[]): string[] | null => {
        if (vertex === target) {
            return [...path, vertex];
        }

        if (visited.has(vertex)) {
            return null;
        }

        visited.add(vertex);
        
        const neighbors = graph.getNeighbors(vertex);
        for (const neighbor of neighbors) {
            const result = dfsPathHelper(neighbor, [...path, vertex]);
            if (result) {
                return result;
            }
        }

        return null;
    };

    const result = dfsPathHelper(start, []);
    return result || [];
};</code></pre>

<h2>DFS 실행 결과</h2>

<h3>시작점: A</h3>
<pre><code>방문 순서: A -> C -> I -> J -> H -> G -> B -> D -> F -> E</code></pre>

<p><strong>설명:</strong></p>
<ul>
<li>A에서 시작하여 C로 이동</li>
<li>C에서 I로 이동하여 J까지 깊이 탐색</li>
<li>백트래킹하여 H, G 탐색</li>
<li>다시 A로 돌아가 B로 이동하여 D, F, E 순서로 탐색</li>
</ul>

<hr>

<h1>예제 그래프</h1>

<p>다음과 같은 구조의 그래프를 사용하여 테스트합니다:</p>

<pre><code>    A
   / \
  B   C
  |   |\\
  D   G H I
  |\      \
  E F      J</code></pre>

<h2>그래프 생성</h2>

<pre><code>export const createExampleGraph = (): Graph => {
    const graph = new Graph();

    // 정점들 추가
    const vertices = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"];
    vertices.forEach(vertex => graph.addVertex(vertex));

    // 간선들 추가 (무방향 그래프)
    const edges = [
        ["A", "B"], ["A", "C"], ["B", "D"], ["C", "G"],
        ["C", "H"], ["C", "I"], ["D", "E"], ["D", "F"], ["I", "J"]
    ];
    
    edges.forEach(([v1, v2]) => graph.addEdge(v1, v2));

    return graph;
};</code></pre>

<hr>

<h1>활용 사례</h1>

<h2>BFS 활용 사례</h2>

<ol>
<li><strong>최단 경로 찾기</strong>: 가중치가 없는 그래프에서 두 정점 간의 최단 경로</li>
<li><strong>웹 크롤링</strong>: 웹페이지 간의 링크를 따라가며 탐색</li>
<li><strong>소셜 네트워크</strong>: 친구 관계에서 특정 거리 내의 모든 사용자 찾기</li>
<li><strong>게임 AI</strong>: 체스나 체커에서 가능한 모든 이동 경로 탐색</li>
<li><strong>네트워크 라우팅</strong>: 패킷이 목적지까지 가는 최단 경로 찾기</li>
</ol>

<h2>DFS 활용 사례</h2>

<ol>
<li><strong>백트래킹</strong>: 퍼즐 해결, 스도쿠, N-퀸 문제</li>
<li><strong>위상 정렬</strong>: 의존성이 있는 작업들의 순서 결정</li>
<li><strong>연결 요소 찾기</strong>: 그래프의 연결된 부분들 찾기</li>
<li><strong>사이클 감지</strong>: 그래프에서 사이클 존재 여부 확인</li>
<li><strong>미로 찾기</strong>: 미로에서 출구까지의 경로 찾기</li>
</ol>

<hr>

<h1>주의사항</h1>

<h2>BFS 주의사항</h2>

<ol>
<li><strong>무한 루프 방지</strong>: 방문한 정점을 다시 방문하지 않도록 <code>visited</code> Set 사용</li>
<li><strong>큐의 특성</strong>: FIFO 방식으로 정점을 처리하여 레벨별 탐색 보장</li>
<li><strong>메모리 고려</strong>: 큰 그래프에서는 메모리 사용량이 많을 수 있음</li>
</ol>

<h2>DFS 주의사항</h2>

<ol>
<li><strong>스택 오버플로우</strong>: 재귀 구현 시 깊이가 깊은 그래프에서 스택 오버플로우 발생 가능</li>
<li><strong>무한 루프 방지</strong>: 방문한 정점을 다시 방문하지 않도록 <code>visited</code> Set 사용</li>
<li><strong>최단 경로 미보장</strong>: DFS는 최단 경로를 보장하지 않음</li>
</ol>

<hr>

<h1>실행 방법</h1>

<pre><code># BFS 테스트 실행
npx ts-node BFS.ts

# DFS 테스트 실행
npx ts-node DFS.ts</code></pre>

<h2>실행 결과 예시</h2>

<pre><code>=== BFS 알고리즘 테스트 ===

그래프 구조:
A: [B, C]
B: [A, D]
C: [A, G, H, I]
D: [B, E, F]
E: [D]
F: [D]
G: [C]
H: [C]
I: [C, J]
J: [I]

BFS (시작점: A):
방문 순서: A -> B -> C -> D -> G -> H -> I -> E -> F -> J

=== DFS 알고리즘 테스트 ===

그래프 구조:
A: [B, C]
B: [A, D]
C: [A, G, H, I]
D: [B, E, F]
E: [D]
F: [D]
G: [C]
H: [C]
I: [C, J]
J: [I]

반복문 DFS (시작점: A):
방문 순서: A -> C -> I -> J -> H -> G -> B -> D -> F -> E

재귀 DFS (시작점: A):
방문 순서: A -> B -> D -> E -> F -> C -> G -> H -> I -> J

경로 찾기 (A -> J):
경로: A -> C -> I -> J

경로 찾기 (C -> F):
경로: C -> A -> B -> D -> F</code></pre>

<hr>

<h1>파일 구조</h1>

<pre><code>BFS_DFS/
├── BFS.ts      # BFS 알고리즘 구현
├── DFS.ts      # DFS 알고리즘 구현 (반복문, 재귀, 경로 찾기)
├── Graph.ts    # 그래프 클래스 구현
└── README.md   # 이 파일</code></pre>

<hr>

<h1>추가 학습 자료</h1>

<ul>
<li>[BFS vs DFS - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/)</li>
<li>[Graph Traversal - Wikipedia](https://en.wikipedia.org/wiki/Graph_traversal)</li>
<li>[Breadth-First Search - Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)</li>
<li>[Depth-First Search - Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)</li>
</ul>
    </div>
</body>
</html>