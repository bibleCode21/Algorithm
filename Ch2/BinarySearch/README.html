<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이진 검색 (Binary Search)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>이진 검색 (Binary Search)</h1>

        <p>이 폴더는 이진 검색 알고리즘의 구현을 포함합니다.</p>

        <h2>파일 목록</h2>

        <h3>BinarySearch.ts</h3>
        <p>이진 검색 알고리즘의 구현과 테스트 코드입니다.</p>

        <h4>구현된 함수들:</h4>
        <ul>
            <li><strong>binarySearch(data, search)</strong>: 이진 검색 알고리즘</li>
            <li><strong>sortedArr</strong>: 테스트용 정렬된 랜덤 배열</li>
        </ul>

        <h2>이진 검색 알고리즘</h2>

        <h3>알고리즘 설명</h3>
        <p>이진 검색은 <strong>정렬된 배열</strong>에서 특정 값을 효율적으로 찾는 알고리즘입니다. 배열의 중간 요소와 비교하여 검색 범위를 절반씩 줄여가며 검색합니다.</p>

        <h3>전제 조건</h3>
        <ul>
            <li><strong>정렬된 배열</strong>: 이진 검색은 반드시 정렬된 배열에서만 사용 가능</li>
            <li><strong>비교 가능한 데이터</strong>: 숫자, 문자열 등 비교 연산이 가능한 데이터</li>
        </ul>

        <h3>동작 원리</h3>
        <ol>
            <li><strong>중간 요소 확인</strong>: 배열의 중간 인덱스 요소를 확인</li>
            <li><strong>비교</strong>: 검색값과 중간 요소를 비교</li>
            <li><strong>범위 축소</strong>:
                <ul>
                    <li>검색값 &lt; 중간값: 왼쪽 절반에서 검색</li>
                    <li>검색값 &gt; 중간값: 오른쪽 절반에서 검색</li>
                    <li>검색값 = 중간값: 검색 완료</li>
                </ul>
            </li>
            <li><strong>재귀 반복</strong>: 범위가 1개 이하가 될 때까지 반복</li>
        </ol>

        <h3>구현</h3>
        <pre><code>export const binarySearch = (data: number[], search: number): boolean => {
  if (data.length === 0 || data === null) {
    return false;
  } else if (data.length === 1 && data[0] !== search) {
    return false;
  } else if (data.length === 1 && data[0] === search) {
    return true;
  } else {
    const mid = Math.floor(data.length / 2);
    if (data[mid] === search) {
      return true;
    } else if (data[mid] &lt; search) {
      return binarySearch(data.slice(mid + 1), search);
    } else {
      return binarySearch(data.slice(0, mid), search);
    }
  }
};</code></pre>

        <h3>코드 분석</h3>

        <h4>1. 기저 케이스들</h4>
        <pre><code>if (data.length === 0 || data === null) {
  return false;
}</code></pre>
        <ul>
            <li>빈 배열이나 null인 경우 false 반환</li>
        </ul>
        <pre><code>else if (data.length === 1 && data[0] !== search) {
  return false;
}</code></pre>
        <ul>
            <li>배열에 요소가 1개이고 검색값과 다른 경우 false 반환</li>
        </ul>
        <pre><code>else if (data.length === 1 && data[0] === search) {
  return true;
}</code></pre>
        <ul>
            <li>배열에 요소가 1개이고 검색값과 같은 경우 true 반환</li>
        </ul>

        <h4>2. 중간 인덱스 계산</h4>
        <pre><code>const mid = Math.floor(data.length / 2);</code></pre>
        <ul>
            <li><code>Math.floor()</code>: 소수점 이하를 버림하여 정수 인덱스 생성</li>
            <li>Python의 <code>//</code> 연산자와 동일한 역할</li>
        </ul>

        <h4>3. 검색값과 중간값 비교</h4>
        <pre><code>if (data[mid] === search) {
  return true;
} else if (data[mid] &lt; search) {
  return binarySearch(data.slice(mid + 1), search);
} else {
  return binarySearch(data.slice(0, mid), search);
}</code></pre>
        <ul>
            <li><strong>같은 경우</strong>: 검색 완료, true 반환</li>
            <li><strong>중간값 &lt; 검색값</strong>: 오른쪽 절반에서 재귀 검색</li>
            <li><strong>중간값 &gt; 검색값</strong>: 왼쪽 절반에서 재귀 검색</li>
        </ul>

        <h4>4. 배열 분할</h4>
        <pre><code>data.slice(mid + 1)  // 오른쪽 절반
data.slice(0, mid)   // 왼쪽 절반</code></pre>
        <ul>
            <li>Python의 <code>data[mid + 1:]</code>와 <code>data[:mid]</code>와 동일한 역할</li>
        </ul>

        <h3>실행 과정 예시</h3>
        <pre><code>정렬된 배열: [11, 22, 25, 34, 64, 90]
검색값: 34

1단계: [11, 22, 25, 34, 64, 90]
       mid = 2, data[2] = 25
       25 &lt; 34 → 오른쪽 절반 검색

2단계: [34, 64, 90]
       mid = 1, data[1] = 64
       64 &gt; 34 → 왼쪽 절반 검색

3단계: [34]
       mid = 0, data[0] = 34
       34 === 34 → 검색 완료!

결과: true</code></pre>

        <h2>시간 복잡도</h2>
        <ul>
            <li><strong>O(log n)</strong>: 매 단계마다 검색 범위가 절반씩 줄어듦</li>
            <li><strong>선형 검색 대비</strong>: O(n) → O(log n)으로 성능 향상</li>
        </ul>

        <h2>공간 복잡도</h2>
        <ul>
            <li><strong>재귀적 구현</strong>: O(log n) - 재귀 호출 스택</li>
            <li><strong>반복적 구현</strong>: O(1) - 추가 메모리 불필요</li>
        </ul>

        <h2>장단점</h2>

        <h3>장점</h3>
        <ol>
            <li><strong>효율성</strong>: O(log n)의 빠른 검색 속도</li>
            <li><strong>예측 가능</strong>: 정렬된 데이터에서 일정한 성능</li>
            <li><strong>메모리 효율</strong>: 반복적 구현 시 O(1) 공간 복잡도</li>
        </ol>

        <h3>단점</h3>
        <ol>
            <li><strong>정렬 필요</strong>: 검색 전에 배열을 정렬해야 함</li>
            <li><strong>정렬 비용</strong>: 정렬에 O(n log n) 시간 소요</li>
            <li><strong>단일 검색</strong>: 여러 번 검색할 때만 효율적</li>
        </ol>

        <h2>최적화 방안</h2>
        <ol>
            <li><strong>반복적 구현</strong>
                <ul>
                    <li>재귀 호출 스택 제거로 공간 복잡도 개선</li>
                </ul>
            </li>
            <li><strong>인덱스 기반 구현</strong>
                <ul>
                    <li>배열 복사 대신 인덱스로 범위 관리</li>
                </ul>
            </li>
            <li><strong>조건 최적화</strong>
                <ul>
                    <li>불필요한 조건문 제거</li>
                </ul>
            </li>
        </ol>

        <h2>사용법</h2>
        <pre><code>import { binarySearch, sortedArr } from './BinarySearch';

console.log('정렬된 배열:', sortedArr);
console.log('검색 결과 (50):', binarySearch(sortedArr, 50));
console.log('검색 결과 (첫 번째 요소):', binarySearch(sortedArr, sortedArr[0]));</code></pre>

        <h2>다른 검색 알고리즘과의 비교</h2>
        <table>
            <thead>
                <tr>
                    <th>알고리즘</th>
                    <th>시간 복잡도</th>
                    <th>공간 복잡도</th>
                    <th>전제 조건</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>이진 검색</td>
                    <td>O(log n)</td>
                    <td>O(log n)</td>
                    <td>정렬된 배열</td>
                </tr>
                <tr>
                    <td>선형 검색</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>없음</td>
                </tr>
                <tr>
                    <td>해시 테이블</td>
                    <td>O(1) 평균</td>
                    <td>O(n)</td>
                    <td>없음</td>
                </tr>
            </tbody>
        </table>

        <h2>이진 검색의 활용</h2>
        <ol>
            <li>정렬된 배열에서 값 찾기</li>
            <li>정렬된 배열에서 삽입 위치 찾기</li>
            <li>이진 탐색 트리에서 검색</li>
            <li>수치 해석에서 근 찾기</li>
            <li>게임에서 최적해 찾기</li>
        </ol>

        <h2>주의사항</h2>
        <ol>
            <li><strong>정렬 필수</strong>: 반드시 정렬된 배열에서만 사용</li>
            <li><strong>중복 처리</strong>: 중복된 값이 있을 때 첫 번째 또는 마지막 위치 결정 필요</li>
            <li><strong>오버플로우</strong>: 큰 배열에서 중간값 계산 시 오버플로우 주의</li>
        </ol>
    </div>
</body>
</html>


