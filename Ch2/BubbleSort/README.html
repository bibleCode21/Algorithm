<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>버블 정렬 (Bubble Sort)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>버블 정렬 (Bubble Sort)</h1>

        <h2>개요</h2>
        <p>버블 정렬은 가장 기본적인 정렬 알고리즘 중 하나입니다. 인접한 두 원소를 비교하여 순서가 잘못되어 있으면 교환하는 방식으로 동작합니다.</p>

        <h2>알고리즘 동작 원리</h2>
        <ol>
            <li>첫 번째 원소부터 시작하여 인접한 원소와 비교</li>
            <li>첫 번째 원소가 두 번째 원소보다 크면 교환</li>
            <li>이 과정을 배열의 끝까지 반복</li>
            <li>한 번의 순회가 끝나면 가장 큰 원소가 배열의 끝에 위치</li>
            <li>남은 원소들에 대해 같은 과정을 반복</li>
        </ol>

        <h2>코드 분석</h2>

        <h3>전체 코드 구조</h3>
        <pre><code>const bubbleSort = (arr: number[]) => {
    let n = arr.length
    if (n == 0) {
        return
    }

    for (let i = 0; i &lt; n - 1; i++) {
        let swap = true
        for (let index = 0; index &lt; n - 1 - i; index++) {
            if (arr[index] &gt; arr[index + 1]) {
                [arr[index], arr[index + 1]] = [arr[index + 1], arr[index]]
                swap = false
            }
        }
        if (swap) {
            break
        }   
    }
}</code></pre>

        <h3>For문 상세 분석</h3>

        <h4>외부 for문: <code>for (let i = 0; i &lt; n - 1; i++)</code></h4>
        <ul>
            <li><strong>목적</strong>: 전체 정렬 과정을 제어하는 라운드</li>
            <li><strong>동작</strong>: 배열의 길이가 n일 때, 최대 n-1번의 라운드가 필요</li>
            <li><strong>최적화</strong>: <code>swap</code> 변수를 통해 이미 정렬된 경우 조기 종료</li>
        </ul>

        <h4>내부 for문: <code>for (let index = 0; index &lt; n - 1 - i; index++)</code></h4>
        <ul>
            <li><strong>목적</strong>: 각 라운드에서 인접한 원소들을 비교하고 교환</li>
            <li><strong>범위</strong>: <code>n - 1 - i</code>까지 비교 (이미 정렬된 부분은 제외)</li>
            <li><strong>동작</strong>: 인접한 두 원소를 비교하여 순서가 잘못되어 있으면 교환</li>
        </ul>

        <h2>실행 예시</h2>

        <h3>초기 배열: <code>[5, 2, 3, 1, 4]</code></h3>
        <p><strong>배열 길이 n = 5</strong></p>

        <h4>1차 라운드 (i = 0)</h4>
        <ul>
            <li>비교 범위: index 0 ~ 3 (n-1-i = 5-1-0 = 4, index &lt; 4이므로 0~3)</li>
            <li><code>swap = true</code>로 시작</li>
        </ul>
        <table>
            <thead>
                <tr>
                    <th>단계</th>
                    <th>비교</th>
                    <th>배열 상태</th>
                    <th>교환 여부</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>arr[0] &gt; arr[1] (5 &gt; 2)</td>
                    <td>[<strong>2, 5</strong>, 3, 1, 4]</td>
                    <td>✅ 교환</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>arr[1] &gt; arr[2] (5 &gt; 3)</td>
                    <td>[2, <strong>3, 5</strong>, 1, 4]</td>
                    <td>✅ 교환</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>arr[2] &gt; arr[3] (5 &gt; 1)</td>
                    <td>[2, 3, <strong>1, 5</strong>, 4]</td>
                    <td>✅ 교환</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>arr[3] &gt; arr[4] (5 &gt; 4)</td>
                    <td>[2, 3, 1, <strong>4, 5</strong>]</td>
                    <td>✅ 교환</td>
                </tr>
            </tbody>
        </table>
        <p><strong>결과</strong>: <code>[2, 3, 1, 4, 5]</code> (가장 큰 수 5가 맨 뒤로)</p>

        <h4>2차 라운드 (i = 1)</h4>
        <ul>
            <li>비교 범위: index 0 ~ 2 (n-1-i = 5-1-1 = 3, index &lt; 3이므로 0~2)</li>
            <li><code>swap = true</code>로 시작</li>
        </ul>
        <table>
            <thead>
                <tr>
                    <th>단계</th>
                    <th>비교</th>
                    <th>배열 상태</th>
                    <th>교환 여부</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>arr[0] &gt; arr[1] (2 &gt; 3)</td>
                    <td>[2, 3, 1, 4, 5]</td>
                    <td>❌ 교환 안함</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>arr[1] &gt; arr[2] (3 &gt; 1)</td>
                    <td>[2, <strong>1, 3</strong>, 4, 5]</td>
                    <td>✅ 교환</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>arr[2] &gt; arr[3] (3 &gt; 4)</td>
                    <td>[2, 1, 3, 4, 5]</td>
                    <td>❌ 교환 안함</td>
                </tr>
            </tbody>
        </table>
        <p><strong>결과</strong>: <code>[2, 1, 3, 4, 5]</code> (두 번째로 큰 수 4가 뒤에서 두 번째로)</p>

        <h4>3차 라운드 (i = 2)</h4>
        <ul>
            <li>비교 범위: index 0 ~ 1 (n-1-i = 5-1-2 = 2, index &lt; 2이므로 0~1)</li>
            <li><code>swap = true</code>로 시작</li>
        </ul>
        <table>
            <thead>
                <tr>
                    <th>단계</th>
                    <th>비교</th>
                    <th>배열 상태</th>
                    <th>교환 여부</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>arr[0] &gt; arr[1] (2 &gt; 1)</td>
                    <td>[<strong>1, 2</strong>, 3, 4, 5]</td>
                    <td>✅ 교환</td>
                </tr>
            </tbody>
        </table>
        <p><strong>결과</strong>: <code>[1, 2, 3, 4, 5]</code> (정렬 완료!)</p>

        <h4>4차 라운드 (i = 3)</h4>
        <ul>
            <li>비교 범위: index 0 ~ 0 (n-1-i = 5-1-3 = 1, index &lt; 1이므로 0~0)</li>
            <li>내부 for문이 실행되지 않음</li>
            <li><code>swap = true</code>이므로 조기 종료</li>
        </ul>

        <h2>최적화 포인트</h2>

        <h3>1. 조기 종료 (Early Termination)</h3>
        <pre><code>if (swap) {
    break
}</code></pre>
        <ul>
            <li>한 라운드에서 교환이 한 번도 일어나지 않으면 이미 정렬된 상태</li>
            <li>불필요한 반복을 줄여 성능 향상</li>
        </ul>

        <h3>2. 범위 최적화</h3>
        <pre><code>for (let index = 0; index &lt; n - 1 - i; index++)</code></pre>
        <ul>
            <li>각 라운드마다 비교 범위를 줄임</li>
            <li>이미 정렬된 부분은 다시 비교하지 않음</li>
        </ul>

        <h2>시간 복잡도</h2>
        <ul>
            <li><strong>최선의 경우</strong>: O(n) - 이미 정렬된 배열</li>
            <li><strong>평균의 경우</strong>: O(n²)</li>
            <li><strong>최악의 경우</strong>: O(n²) - 역순으로 정렬된 배열</li>
        </ul>

        <h2>공간 복잡도</h2>
        <ul>
            <li><strong>O(1)</strong> - 추가 메모리 공간이 거의 필요하지 않음</li>
        </ul>

        <h2>장단점</h2>

        <h3>장점</h3>
        <ul>
            <li>구현이 간단하고 이해하기 쉬움</li>
            <li>추가 메모리 공간이 거의 필요하지 않음</li>
            <li>안정 정렬 (Stable Sort)</li>
        </ul>

        <h3>단점</h3>
        <ul>
            <li>시간 복잡도가 O(n²)로 비효율적</li>
            <li>대용량 데이터에는 부적합</li>
        </ul>

        <h2>사용 사례</h2>
        <ul>
            <li>교육 목적의 알고리즘 학습</li>
            <li>작은 크기의 데이터 정렬</li>
            <li>거의 정렬된 데이터의 정렬</li>
        </ul>
    </div>
</body>
</html>

