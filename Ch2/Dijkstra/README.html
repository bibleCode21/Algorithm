<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra Algorithm (다익스트라 알고리즘)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        hr {
            border: none;
            border-top: 2px solid #e0e0e0;
            margin: 2rem 0;
        }

        a {
            color: #3498db;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
<h1>최단 경로 알고리즘 (Shortest Path)</h1>

<h2>목차</h2>
<ul>
<li>[다익스트라 알고리즘](#다익스트라-알고리즘-dijkstras-algorithm)</li>
<li>[개념](#개념)</li>
<li>[특징](#특징)</li>
<li>[동작 원리](#동작-원리)</li>
<li>[구현 세부사항](#구현-세부사항)</li>
<li>[MinHeap 클래스](#minheap-클래스)</li>
<li>[상향 조정 (heapifyUp)](#상향-조정-heapifyup)</li>
<li>[하향 조정 (heapifyDown)](#하향-조정-heapifydown)</li>
<li>[pop() 연산 상세 설명](#pop-연산-상세-설명)</li>
<li>[형제 노드 간 크기 관계](#형제-노드-간-크기-관계)</li>
<li>[사용 예시](#사용-예시)</li>
<li>[다익스트라 알고리즘 동작 예시](#다익스트라-알고리즘-동작-예시)</li>
<li>[장점](#장점)</li>
<li>[단점](#단점)</li>
<li>[실행 방법](#실행-방법)</li>
</ul>

<hr>

<h2>다익스트라 알고리즘 (Dijkstra's Algorithm)</h2>

<h3>개념</h3>
<p>다익스트라 알고리즘은 그래프에서 한 노드에서 다른 모든 노드까지의 최단 거리를 구하는 알고리즘입니다. 음수 가중치가 없는 그래프에서 사용할 수 있습니다.</p>

<h3>특징</h3>
<ul>
<li><strong>시간 복잡도</strong>: O((V + E) log V) - V는 노드 수, E는 간선 수</li>
<li><strong>공간 복잡도</strong>: O(V)</li>
<li><strong>그리디 알고리즘</strong>: 매 단계에서 현재까지 알려진 최단 거리의 노드를 선택</li>
<li><strong>우선순위 큐</strong>: 최소 힙을 사용하여 효율적으로 최소 거리 노드를 선택</li>
</ul>

<h3>동작 원리</h3>
<ol>
<li>시작 노드의 거리를 0으로, 나머지 노드의 거리를 무한대로 초기화</li>
<li>우선순위 큐에 시작 노드를 삽입</li>
<li>큐에서 가장 거리가 짧은 노드를 꺼냄</li>
<li>해당 노드와 연결된 이웃 노드들의 거리를 업데이트</li>
<li>더 짧은 경로가 발견되면 큐에 삽입</li>
<li>큐가 빌 때까지 반복</li>
</ol>

<h3>구현 세부사항</h3>

<h4>MinHeap 클래스</h4>
<p>Python의 <code>heapq</code>와 유사한 기능을 제공하는 최소 힙 구현입니다.</p>

<p><strong>힙이란?</strong></p>
<ul>
<li>완전 이진 트리 기반의 자료구조</li>
<li>배열로 구현하며, 인덱스 i의 노드에 대해:</li>
<li>부모: <code>Math.floor((i-1)/2)</code></li>
<li>왼쪽 자식: <code>2*i + 1</code></li>
<li>오른쪽 자식: <code>2*i + 2</code></li>
</ul>

<p><strong>최소 힙의 특성:</strong></p>
<ul>
<li>부모 노드는 항상 자식 노드보다 작거나 같음</li>
<li>루트 노드(인덱스 0)가 항상 최소값</li>
<li><strong>중요</strong>: 왼쪽 자식과 오른쪽 자식 간의 크기는 상관없음!</li>
</ul>

<p><strong>주요 메서드:</strong></p>
<ul>
<li><code>push(priority, value)</code>: 요소 추가 - O(log n)</li>
<li><code>pop()</code>: 최소값 제거 및 반환 - O(log n)</li>
<li><code>isEmpty()</code>: 힙이 비었는지 확인 - O(1)</li>
</ul>

<h4>상향 조정 (heapifyUp)</h4>
<p>새로운 요소를 힙의 맨 끝에 추가한 후, 힙 속성을 복구하는 과정입니다.</p>

<p><strong>동작 과정:</strong></p>
<ol>
<li>새로 추가된 요소(맨 끝 인덱스)부터 시작</li>
<li>부모 노드와 비교</li>
<li>현재 노드가 부모보다 작으면 교환</li>
<li>루트에 도달하거나 부모보다 크거나 같을 때까지 반복</li>
</ol>

<p><strong>예시:</strong></p>
<pre><code>[1, 5, 3]에 0을 추가
→ [1, 5, 3, 0]
→ 0이 부모(5)보다 작으므로 교환 → [1, 0, 3, 5]
→ 0이 부모(1)보다 작으므로 교환 → [0, 1, 3, 5]</code></pre>

<h4>하향 조정 (heapifyDown)</h4>
<p>루트 노드를 제거한 후, 마지막 요소를 루트로 옮기고 힙 속성을 복구하는 과정입니다.</p>

<p><strong>동작 과정:</strong></p>
<ol>
<li>루트(인덱스 0)부터 시작</li>
<li>왼쪽 자식과 오른쪽 자식 중 가장 작은 값 찾기</li>
<li>현재 노드가 가장 작은 자식보다 크면 교환</li>
<li>리프 노드에 도달하거나 자식들보다 작거나 같을 때까지 반복</li>
</ol>

<p><strong>예시:</strong></p>
<pre><code>[1, 3, 2, 7, 5]에서 1(루트)을 제거하고 5를 루트로 이동
→ [5, 3, 2, 7]
→ 5가 자식(2, 3) 중 최소값(2)보다 크므로 교환 → [2, 3, 5, 7]
→ 5가 자식(7)보다 작으므로 종료</code></pre>

<h4>pop() 연산 상세 설명</h4>
<p>pop() 연산이 헷갈릴 수 있으므로 단계별로 설명합니다.</p>

<p><strong>핵심 포인트:</strong></p>
<ul>
<li>제거하려는 것: <code>heap[0]</code> (첫 번째 요소 = 최소값)</li>
<li>하지만 첫 번째를 바로 제거하면 배열에 구멍이 생김</li>
<li>그래서 "마지막 요소"를 "첫 번째 위치"로 옮기고, 배열 크기를 줄임</li>
</ul>

<p><strong>단계별 동작: <code>[1, 3, 2, 7]</code>에서 pop()</strong></p>
<pre><code>1. root = heap[0]           // 1을 임시 저장 (반환할 값)
2. heap.pop()               // 마지막 7을 제거, 배열 → [1, 3, 2]
3. heap[0] = 7              // 첫 번째에 7을 넣음 → [7, 3, 2]
4. heapifyDown()            // 7을 올바른 위치로 → [2, 3, 7]
5. return root              // 1 반환</code></pre>

<p><strong>왜 이렇게 하나?</strong></p>
<ul>
<li>배열 중간 제거: O(n) - 모든 요소를 한 칸씩 이동</li>
<li>배열 마지막 제거: O(1) - 크기만 줄이면 됨</li>
<li>재정렬(heapifyDown): O(log n)</li>
<li><strong>총 O(log n)</strong>으로 효율적!</li>
</ul>

<p><strong>중요:</strong> <code>heap[0]</code> (첫 번째 요소)와 <code>heap.pop()</code> (마지막 요소)은 서로 다른 요소입니다!</p>

<h4>형제 노드 간 크기 관계</h4>
<p>많은 사람들이 궁금해하는 부분입니다.</p>

<p><strong>질문: 왼쪽 자식이 오른쪽 자식보다 커도 되나요?</strong></p>

<p><strong>답변: 네! 완전히 괜찮습니다!</strong></p>

<p><strong>힙의 규칙:</strong></p>
<ol>
<li>✅ 부모는 자식들보다 작아야 함 (최소 힙)</li>
<li>✅ 왼쪽 자식과 오른쪽 자식 간의 크기는 상관없음!</li>
</ol>

<p><strong>예시 1: <code>[1, 2, 5]</code> - 왼쪽 < 오른쪽</strong></p>
<pre><code>    1
   / \
  2   5</code></pre>
<p>✓ 유효한 힙</p>

<p><strong>예시 2: <code>[1, 5, 2]</code> - 왼쪽 > 오른쪽</strong></p>
<pre><code>    1
   / \
  5   2</code></pre>
<p>✓ 유효한 힙 (왼쪽이 오른쪽보다 크지만 괜찮음!)</p>

<p><strong>예시 3: <code>[3, 7, 5]</code> - 왼쪽 > 오른쪽</strong></p>
<pre><code>    3
   / \
  7   5</code></pre>
<p>✓ 유효한 힙</p>

<p><strong>핵심:</strong></p>
<ul>
<li>힙은 "부모-자식" 관계만 중요하고, "형제" 간 관계는 무시!</li>
<li>이것이 힙이 "부분 정렬" 자료구조인 이유</li>
<li>완전 정렬이 아니라서 O(log n)에 삽입/삭제 가능!</li>
</ul>

<h4>dijkstra 함수</h4>
<ul>
<li>그래프와 시작 노드를 입력받음</li>
<li>각 노드까지의 최단 거리를 담은 객체를 반환</li>
<li>visited Set을 사용하여 이미 처리된 노드를 추적</li>
<li>MinHeap을 우선순위 큐로 활용하여 항상 최단 거리 노드를 먼저 처리</li>
</ul>

<h3>사용 예시</h3>
<pre><code>const graph = {
    'A': { 'B': 2, 'C': 5 },
    'B': { 'A': 2, 'C': 3, 'D': 1 },
    'C': { 'A': 5, 'B': 3, 'D': 2 },
    'D': { 'B': 1, 'C': 2 }
};

const distances = dijkstra(graph, 'A');
// { A: 0, B: 2, C: 5, D: 3 }</code></pre>

<h3>다익스트라 알고리즘 동작 예시</h3>

<p>위 그래프에서 A를 시작점으로 했을 때의 단계별 동작:</p>

<p><strong>초기 상태:</strong></p>
<pre><code>거리: { A: 0, B: ∞, C: ∞, D: ∞ }
우선순위 큐: [(0, A)]
방문: []</code></pre>

<p><strong>1단계: A 노드 처리</strong></p>
<ul>
<li>큐에서 (0, A) 꺼냄</li>
<li>A의 이웃: B(거리 2), C(거리 5)</li>
<li>거리 업데이트: B = 0+2 = 2, C = 0+5 = 5</li>
<li>큐에 추가: [(2, B), (5, C)]</li>
</ul>

<p><strong>2단계: B 노드 처리</strong></p>
<ul>
<li>큐에서 (2, B) 꺼냄 (최소값)</li>
<li>B의 이웃: A(거리 2), C(거리 3), D(거리 1)</li>
<li>A는 이미 방문, C = min(5, 2+3) = 5 (변경 없음)</li>
<li>D = 2+1 = 3으로 업데이트</li>
<li>큐 상태: [(3, D), (5, C)]</li>
</ul>

<p><strong>3단계: D 노드 처리</strong></p>
<ul>
<li>큐에서 (3, D) 꺼냄 (최소값)</li>
<li>D의 이웃: B(거리 1), C(거리 2)</li>
<li>B는 이미 방문, C = min(5, 3+2) = 5 (변경 없음)</li>
<li>큐 상태: [(5, C)]</li>
</ul>

<p><strong>4단계: C 노드 처리</strong></p>
<ul>
<li>큐에서 (5, C) 꺼냄</li>
<li>모든 노드 방문 완료</li>
</ul>

<p><strong>최종 결과:</strong></p>
<pre><code>{ A: 0, B: 2, C: 5, D: 3 }</code></pre>

<p><strong>최단 경로:</strong></p>
<ul>
<li>A → A: 0 (시작점)</li>
<li>A → B: 2 (A → B)</li>
<li>A → C: 5 (A → C)</li>
<li>A → D: 3 (A → B → D)</li>
</ul>

<h3>장점</h3>
<ul>
<li>음수 가중치가 없는 그래프에서 정확한 최단 경로를 찾음</li>
<li>한 노드에서 모든 노드까지의 최단 거리를 한 번에 계산</li>
<li>우선순위 큐를 사용하여 효율적</li>
</ul>

<h3>단점</h3>
<ul>
<li>음수 가중치를 가진 그래프에서는 사용 불가 (벨만-포드 알고리즘 사용)</li>
<li>모든 노드 간의 최단 경로를 구하려면 각 노드마다 실행 필요 (플로이드-워셜 알고리즘 사용)</li>
</ul>

<h3>실행 방법</h3>

<p><strong>코드 실행:</strong></p>
<pre><code>npx ts-node Ch2/ShortestPath/Dijkstra.ts</code></pre>

<p><strong>실행 시 출력되는 내용:</strong></p>
<ol>
<li>다익스트라 알고리즘 테스트 결과</li>
<li>MinHeap 동작 확인</li>
<li>pop() 연산의 단계별 설명</li>
<li>두 번째 pop() 연산 예제</li>
<li>왼쪽/오른쪽 자식의 크기 관계 설명</li>
</ol>

<p>코드에는 실제 동작을 확인할 수 있는 다양한 예제가 포함되어 있습니다!</p>

<hr>

<h2>핵심 요약</h2>

<h3>힙의 3가지 핵심</h3>
<ol>
<li><strong>부모는 자식보다 작다</strong> (최소 힙의 경우)</li>
<li><strong>형제끼리의 크기는 상관없다</strong> (왼쪽 vs 오른쪽)</li>
<li><strong>배열로 구현하되 트리처럼 동작한다</strong></li>
</ol>

<h3>pop() 연산의 핵심</h3>
<pre><code>heap[0] (첫 번째) ≠ heap.pop() (마지막)</code></pre>
<ul>
<li>첫 번째를 저장하고</li>
<li>마지막을 제거해서 첫 번째에 넣고</li>
<li>재정렬한다</li>
</ul>

<h3>다익스트라의 핵심</h3>
<ul>
<li><strong>그리디</strong>: 항상 현재 최단 거리 노드를 선택</li>
<li><strong>최소 힙</strong>: O(log n)으로 최소값을 효율적으로 추출</li>
<li><strong>결과</strong>: O((V + E) log V)의 빠른 최단 경로 계산</li>
</ul>



    </div>
</body>
</html>