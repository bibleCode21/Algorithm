<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>동적 계획법 (Dynamic Programming)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>동적 계획법 (Dynamic Programming)</h1>

        <p>이 폴더는 동적 계획법을 사용한 알고리즘들의 구현을 포함합니다.</p>

        <h2>파일 목록</h2>

        <h3>DynamicPlan.ts</h3>
        <p>동적 계획법을 사용한 알고리즘들의 모음입니다.</p>

        <h4>구현된 함수들:</h4>
        <ul>
            <li><strong>fibonacci(n)</strong>: 피보나치 수열 계산 (재귀적)</li>
            <li><strong>tileWays(n)</strong>: 2×1 타일링 문제 (재귀적)</li>
            <li><strong>triangle(num)</strong>: 삼각형 수열 계산 (동적 계획법)</li>
        </ul>

        <h2>2×1 타일링 문제 (Dynamic Programming)</h2>

        <h3>문제 설명</h3>
        <p>2×n 크기의 직사각형을 <strong>2×1 타일과 1×2 타일</strong>로 채우는 방법의 수를 구하는 문제입니다.</p>

        <h3>해결 방법</h3>
        <p>이 문제는 피보나치 수열과 동일한 패턴을 가집니다:</p>
        <ul>
            <li><code>f(n) = f(n-1) + f(n-2)</code></li>
            <li><code>f(1) = 1</code> (2×1 직사각형: 세로로 1개)</li>
            <li><code>f(2) = 2</code> (2×2 직사각형: 세로로 2개 또는 가로로 2개)</li>
        </ul>

        <h3>타일 배치 방법</h3>
        <ul>
            <li><strong>2×1 타일</strong>: 세로로 배치</li>
            <li><strong>1×2 타일</strong>: 가로로 배치 (2개를 나란히 배치)</li>
        </ul>

        <h3>예시</h3>
        <ul>
            <li>n=1: 1가지 방법 (2×1 타일 1개)</li>
            <li>n=2: 2가지 방법 (2×1 타일 2개 또는 1×2 타일 2개)</li>
            <li>n=3: 3가지 방법</li>
            <li>n=4: 5가지 방법</li>
            <li>n=5: 8가지 방법</li>
        </ul>

        <h3>구현</h3>
        <pre><code>const tileWays = (n: number): number => {
  if (n &lt;= 2) return n;
  return tileWays(n - 1) + tileWays(n - 2);
};</code></pre>

        <h2>삼각형 수열 문제 (Dynamic Programming)</h2>

        <h3>문제 설명</h3>
        <p>삼각형 수열은 다음과 같은 점화식을 따릅니다:</p>
        <ul>
            <li><code>T(n) = T(n-2) + T(n-3)</code></li>
            <li><code>T(1) = T(2) = T(3) = 1</code></li>
        </ul>

        <h3>해결 방법</h3>
        <p>동적 계획법을 사용하여 중복 계산을 피하고 효율적으로 해결합니다:</p>
        <ol>
            <li><strong>기저 케이스</strong>: n ≤ 3일 때 1 반환</li>
            <li><strong>캐시 배열</strong>: 계산된 값을 저장할 배열 생성</li>
            <li><strong>점진적 계산</strong>: 4부터 n까지 순차적으로 계산</li>
        </ol>

        <h3>예시</h3>
        <ul>
            <li>T(1) = 1</li>
            <li>T(2) = 1</li>
            <li>T(3) = 1</li>
            <li>T(4) = T(2) + T(1) = 1 + 1 = 2</li>
            <li>T(5) = T(3) + T(2) = 1 + 1 = 2</li>
            <li>T(6) = T(4) + T(3) = 2 + 1 = 3</li>
        </ul>

        <h3>구현</h3>
        <pre><code>const triangle = (num: number): number => {
  // 기저 케이스
  if (num &lt;= 3) return 1;
  
  // 캐시 배열 초기화
  const cache: number[] = [1, 1, 1];
  
  // 동적 계획법으로 계산
  for (let i = 3; i &lt; num; i++) {
    cache.push(cache[i - 2] + cache[i - 3]);
  }
  
  return cache[num - 1];
};</code></pre>

        <h2>사용법</h2>
        <pre><code>import { fibonacci, tileWays, triangle } from './DynamicPlan';

console.log(fibonacci(10)); // 55
console.log(tileWays(5)); // 8
console.log(triangle(10)); // 9</code></pre>

        <h2>시간 복잡도</h2>
        <ul>
            <li><strong>fibonacci</strong>: O(2^n) (재귀적 구현)</li>
            <li><strong>tileWays</strong>: O(2^n) (재귀적 구현)</li>
            <li><strong>triangle</strong>: O(n) (동적 계획법 사용)</li>
        </ul>

        <h2>공간 복잡도</h2>
        <ul>
            <li><strong>fibonacci</strong>: O(n) (재귀 호출 스택)</li>
            <li><strong>tileWays</strong>: O(n) (재귀 호출 스택)</li>
            <li><strong>triangle</strong>: O(n) (캐시 배열)</li>
        </ul>

        <h2>동적 계획법의 장점</h2>
        <ol>
            <li><strong>중복 계산 방지</strong>: 같은 부분 문제를 여러 번 계산하지 않음</li>
            <li><strong>효율성 향상</strong>: 지수적 시간 복잡도를 선형 시간 복잡도로 개선</li>
            <li><strong>메모리 효율성</strong>: 필요한 계산 결과만 저장</li>
        </ol>
    </div>
</body>
</html>

