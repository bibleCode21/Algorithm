<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greedy Algorithm (그리디 알고리즘)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        hr {
            border: none;
            border-top: 2px solid #e0e0e0;
            margin: 2rem 0;
        }

        a {
            color: #3498db;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
<h1>그리디 알고리즘 (Greedy Algorithm)</h1>

<h2>개요</h2>

<p>그리디 알고리즘은 각 단계에서 가장 좋아 보이는 선택을 하는 알고리즘입니다. 전체적인 최적해를 구하기 위해 각 단계에서 지역적으로 최적인 선택을 하는 방식으로, 간단하면서도 효과적인 해결책을 제공합니다.</p>

<h2>특징</h2>

<ul>
<li><strong>지역 최적 선택</strong>: 각 단계에서 가장 좋아 보이는 선택을 함</li>
<li><strong>간단한 구현</strong>: 복잡한 데이터 구조나 복잡한 로직이 필요하지 않음</li>
<li><strong>빠른 실행</strong>: 일반적으로 O(n log n) 또는 O(n)의 시간 복잡도를 가짐</li>
<li><strong>제한사항</strong>: 모든 문제에 적용할 수 없으며, 때로는 최적해를 보장하지 않음</li>
</ul>

<h2>포함된 알고리즘</h2>

<p>이 디렉토리에는 세 가지 대표적인 그리디 알고리즘 예제가 포함되어 있습니다:</p>

<h3>1. 동전 개수 최적화 문제 (Coin Change Problem)</h3>

<p><strong>문제</strong>: 주어진 금액을 만들기 위해 필요한 최소 동전 개수를 구하는 문제</p>

<p><strong>그리디 전략</strong>: 큰 동전부터 최대한 많이 사용</p>

<p><strong>시간 복잡도</strong>: O(n log n) (정렬) + O(n) (동전 선택) = O(n log n)</p>

<p><strong>공간 복잡도</strong>: O(n)</p>

<p><strong>예시</strong>:</p>
<pre><code>동전 종류: [500, 100, 50, 1]
목표 금액: 4260원
결과: 500원×8 + 100원×2 + 50원×1 + 1원×10 = 21개</code></pre>

<p><strong>핵심 코드</strong>:</p>
<pre><code>function minCoinCount(cList: number[], target: number): number {
    let coinCount: number = 0;
    const sortedCoinList = [...cList].sort((a, b) => b - a);
    
    for (const coin of sortedCoinList) {
        if (target === 0) break;
        const currentCoinCount = Math.floor(target / coin);
        coinCount += currentCoinCount;
        target = target % coin;
    }
    
    return coinCount;
}</code></pre>

<h3>2. 분할 가능한 배낭 문제 (Fractional Knapsack Problem)</h3>

<p><strong>문제</strong>: 제한된 용량의 배낭에 최대 가치를 담는 문제 (아이템을 분할할 수 있음)</p>

<p><strong>그리디 전략</strong>: 무게당 가치가 높은 아이템부터 선택</p>

<p><strong>시간 복잡도</strong>: O(n log n) (정렬) + O(n) (선택) = O(n log n)</p>

<p><strong>공간 복잡도</strong>: O(n)</p>

<p><strong>예시</strong>:</p>
<pre><code>아이템: [(10, 10), (15, 12), (20, 10), (25, 8), (30, 5)]
용량: 30
결과: 무게당 가치 순으로 정렬하여 선택</code></pre>

<p><strong>핵심 코드</strong>:</p>
<pre><code>function getMaxValue(items: Array<[number, number]>, capacity: number): KnapsackResult {
    const sortedItems: Item[] = items
        .map(([weight, value]) => ({
            weight, value,
            valuePerWeight: value / weight
        }))
        .sort((a, b) => b.valuePerWeight - a.valuePerWeight);
    
    // 그리디 선택 로직...
}</code></pre>

<h3>3. 작업 스케줄링 문제 (Job Scheduling Problem)</h3>

<p><strong>문제</strong>: 여러 작업을 처리할 때 전체 대기 시간을 최소화하는 순서를 찾는 문제</p>

<p><strong>그리디 전략</strong>: 처리 시간이 짧은 작업부터 처리</p>

<p><strong>시간 복잡도</strong>: O(n log n) (정렬) + O(n) (계산) = O(n log n)</p>

<p><strong>공간 복잡도</strong>: O(n)</p>

<p><strong>예시</strong>:</p>
<pre><code>작업 처리 시간: [3, 1, 4, 3, 2]
최적 순서: [1, 2, 3, 3, 4]
총 대기 시간: 1 + 3 + 6 + 9 + 13 = 32</code></pre>

<p><strong>핵심 코드</strong>:</p>
<pre><code>function calculateTotalWaitingTime(processingTimes: number[], shouldSort: boolean = true): SchedulingResult {
    // 정렬 여부에 따라 처리 순서 결정
    const orderedTimes: number[] = shouldSort 
        ? [...processingTimes].sort((a, b) => a - b)
        : [...processingTimes];
    
    let totalWaitingTime: number = 0;
    let currentWaitingTime: number = 0;
    const individualWaitingTimes: number[] = [];
    
    for (const time of orderedTimes) {
        currentWaitingTime += time;
        totalWaitingTime += currentWaitingTime;
        individualWaitingTimes.push(currentWaitingTime);
    }
    
    return {
        totalWaitingTime,
        processingOrder: orderedTimes,
        individualWaitingTimes
    };
}</code></pre>

<h2>실행 방법</h2>

<pre><code># TypeScript 컴파일
tsc Greedy.ts

# 실행
node Greedy.js</code></pre>

<p>또는</p>

<pre><code># ts-node를 사용한 직접 실행
npx ts-node Greedy.ts</code></pre>

<h2>출력 예시</h2>

<pre><code>=== 동전 개수 최적화 테스트 ===

4260원을 만드는데 필요한 최소 동전 개수:
Coin details: [
  { coin: 500, count: 8 },
  { coin: 100, count: 2 },
  { coin: 50, count: 1 },
  { coin: 1, count: 10 }
]
결과: 21개

=== 배낭 문제 (분할 가능) 테스트 ===
아이템 목록 (무게, 가치): [[10, 10], [15, 12], [20, 10], [25, 8], [30, 5]]

최종 결과:
총 가치: 24.00
상세 내역:
  1. 무게: 10, 가치: 10, 비율: 1.00
  2. 무게: 15, 가치: 12, 비율: 1.00
  3. 무게: 20, 가치: 10, 비율: 0.25

=== 작업 스케줄링 문제 테스트 ===
원본 작업 처리 시간: [3, 1, 4, 3, 2]

최적 처리 순서 (짧은 시간부터): [1, 2, 3, 3, 4]
개별 대기 시간: [1, 3, 6, 9, 13]
총 대기 시간: 32

원본 순서로 처리했을 때: [3, 1, 4, 3, 2]
개별 대기 시간: [3, 4, 8, 11, 13]
총 대기 시간: 39

최적화로 인한 대기 시간 단축: 7 (17.9% 개선)</code></pre>

<h2>그리디 알고리즘의 장단점</h2>

<h3>장점</h3>
<ul>
<li><strong>구현이 간단</strong>: 직관적이고 이해하기 쉬움</li>
<li><strong>빠른 실행</strong>: 일반적으로 효율적인 시간 복잡도</li>
<li><strong>메모리 효율적</strong>: 추가적인 복잡한 데이터 구조가 필요하지 않음</li>
<li><strong>실시간 처리</strong>: 스트리밍 데이터나 실시간 시스템에 적합</li>
</ul>

<h3>단점</h3>
<ul>
<li><strong>최적해 보장 안됨</strong>: 모든 문제에서 최적해를 보장하지 않음</li>
<li><strong>제한적 적용</strong>: 특정 조건을 만족하는 문제에만 적용 가능</li>
<li><strong>후회 불가</strong>: 한 번 선택한 것은 되돌릴 수 없음</li>
</ul>

<h2>그리디 알고리즘 적용 가능 조건</h2>

<ol>
<li><strong>탐욕적 선택 특성 (Greedy Choice Property)</strong>: 각 단계에서 지역 최적 선택이 전체 최적해로 이어짐</li>
<li><strong>최적 부분 구조 (Optimal Substructure)</strong>: 문제의 최적해가 부분 문제의 최적해로 구성됨</li>
</ol>

<h2>추가 학습 자료</h2>

<ul>
<li>[GeeksforGeeks - Greedy Algorithms](https://www.geeksforgeeks.org/greedy-algorithms/)</li>
<li>[Wikipedia - Greedy Algorithm](https://en.wikipedia.org/wiki/Greedy_algorithm)</li>
<li>[Algorithm Design Manual - Greedy Algorithms](https://www.algorist.com/)</li>
</ul>

<h2>관련 문제들</h2>

<ul>
<li><strong>활동 선택 문제 (Activity Selection Problem)</strong></li>
<li><strong>허프만 코딩 (Huffman Coding)</strong></li>
<li><strong>최소 신장 트리 (Minimum Spanning Tree)</strong></li>
<li><strong>최단 경로 문제 (Shortest Path Problem)</strong></li>
<li><strong>회의실 배정 문제 (Meeting Room Assignment)</strong></li>
</ul>

    </div>
</body>
</html>