<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Sort (퀵 정렬)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans KR', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .container {
            background: white;
            padding: 2.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #34495e;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-left: 0.5rem;
            border-left: 4px solid #3498db;
        }

        h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }

        h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #666;
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }

        p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }

        code {
            background-color: #f4f4f4;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
            line-height: 1.5;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            font-size: 0.9rem;
        }

        strong {
            font-weight: 600;
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 0.75rem;
            text-align: left;
        }

        th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        hr {
            border: none;
            border-top: 2px solid #e0e0e0;
            margin: 2rem 0;
        }

        a {
            color: #3498db;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
<h1>퀵 정렬 (Quick Sort)</h1>

<p>이 폴더는 퀵 정렬 알고리즘의 구현을 포함합니다.</p>

<h2>파일 목록</h2>

<h3>QuickSort.ts</h3>
<p>퀵 정렬 알고리즘의 구현과 테스트 코드입니다.</p>

<h4>구현된 함수들:</h4>

<ul>
<li><strong>quickSort(arr)</strong>: 퀵 정렬 알고리즘</li>
<li><strong>arr</strong>: 테스트용 랜덤 배열</li>
</ul>

<h2>퀵 정렬 알고리즘</h2>

<h3>알고리즘 설명</h3>
<p>퀵 정렬은 <strong>분할 정복(Divide and Conquer)</strong> 방식의 정렬 알고리즘입니다. 피벗(pivot)을 선택하여 배열을 두 부분으로 나누고, 각 부분을 재귀적으로 정렬합니다.</p>

<h3>동작 원리</h3>

<ol>
<li><strong>피벗 선택</strong>: 배열의 중간 요소를 피벗으로 선택</li>
<li><strong>분할</strong>: 피벗보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 분할</li>
<li><strong>재귀 정렬</strong>: 왼쪽과 오른쪽 부분을 각각 재귀적으로 정렬</li>
<li><strong>병합</strong>: 정렬된 왼쪽 부분 + 피벗 + 정렬된 오른쪽 부분</li>
</ol>

<h3>구현</h3>
<pre><code>export const quickSort = (arr: number[]): number[] => {
  if (arr.length <= 1) return arr;

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter((num) => num < pivot);
  const right = arr.filter((num) => num > pivot);
  return [...quickSort(left), pivot, ...quickSort(right)];
};</code></pre>

<h3>코드 분석</h3>

<h4>1. 기저 케이스</h4>
<pre><code>if (arr.length <= 1) return arr;</code></pre>
<ul>
<li>배열의 길이가 1 이하일 때는 이미 정렬된 상태로 간주</li>
</ul>

<h4>2. 피벗 선택</h4>
<pre><code>const pivot = arr[Math.floor(arr.length / 2)];</code></pre>
<ul>
<li>배열의 중간 인덱스 요소를 피벗으로 선택</li>
<li><code>Math.floor(arr.length / 2)</code>: 중간 인덱스 계산</li>
</ul>

<h4>3. 분할</h4>
<pre><code>const left = arr.filter((num) => num < pivot);
const right = arr.filter((num) => num > pivot);</code></pre>
<ul>
<li><code>filter()</code> 메서드를 사용하여 피벗보다 작은/큰 요소들을 분리</li>
<li>피벗과 같은 값은 제외 (중복 처리)</li>
</ul>

<h4>4. 재귀 및 병합</h4>
<pre><code>return [...quickSort(left), pivot, ...quickSort(right)];</code></pre>
<ul>
<li>스프레드 연산자(<code>...</code>)를 사용하여 배열 병합</li>
<li>왼쪽 부분과 오른쪽 부분을 각각 재귀적으로 정렬</li>
</ul>

<h3>실행 과정 예시</h3>

<pre><code>원본 배열: [64, 34, 25, 12, 22, 11, 90]
피벗: 12 (중간 요소)

분할:
- left: [11] (12보다 작은 요소들)
- pivot: 12
- right: [64, 34, 25, 22, 90] (12보다 큰 요소들)

재귀 호출:
- quickSort([11]) → [11]
- quickSort([64, 34, 25, 22, 90]) → [22, 25, 34, 64, 90]

최종 결과: [11, 12, 22, 25, 34, 64, 90]</code></pre>

<h2>퀵소트 재귀 과정 상세 분석</h2>

<h3>재귀 호출 스택과 분할 과정</h3>

<p>퀵소트의 재귀 과정을 단계별로 자세히 살펴보겠습니다. 예시로 <code>[38, 27, 43, 3, 9, 82, 10]</code> 배열을 사용합니다.</p>

<h4>1단계: 최초 호출</h4>
<pre><code>quickSort([38, 27, 43, 3, 9, 82, 10])
├─ 피벗: 3 (인덱스 3)
├─ left: [] (3보다 작은 요소들 - 없음)
├─ right: [38, 27, 43, 9, 82, 10] (3보다 큰 요소들)
└─ return [...quickSort([]), 3, ...quickSort([38, 27, 43, 9, 82, 10])]</code></pre>

<h4>2단계: 왼쪽 부분 처리</h4>
<pre><code>quickSort([])
├─ 길이가 0이므로 기저 케이스
└─ return []</code></pre>

<h4>3단계: 오른쪽 부분 처리 (첫 번째 재귀)</h4>
<pre><code>quickSort([38, 27, 43, 9, 82, 10])
├─ 피벗: 43 (인덱스 2)
├─ left: [38, 27, 9, 10] (43보다 작은 요소들)
├─ right: [82] (43보다 큰 요소들)
└─ return [...quickSort([38, 27, 9, 10]), 43, ...quickSort([82])]</code></pre>

<h4>4단계: 오른쪽 부분의 왼쪽 처리 (두 번째 재귀)</h4>
<pre><code>quickSort([38, 27, 9, 10])
├─ 피벗: 9 (인덱스 2)
├─ left: [9] (9보다 작은 요소들)
├─ right: [38, 27, 10] (9보다 큰 요소들)
└─ return [...quickSort([9]), 9, ...quickSort([38, 27, 10])]</code></pre>

<h4>5단계: 더 깊은 재귀들</h4>
<pre><code>quickSort([9]) → [9] (기저 케이스)

quickSort([38, 27, 10])
├─ 피벗: 27 (인덱스 1)
├─ left: [10] (27보다 작은 요소들)
├─ right: [38] (27보다 큰 요소들)
└─ return [...quickSort([10]), 27, ...quickSort([38])]

quickSort([10]) → [10] (기저 케이스)
quickSort([38]) → [38] (기저 케이스)</code></pre>

<h4>6단계: 오른쪽 부분의 오른쪽 처리</h4>
<pre><code>quickSort([82]) → [82] (기저 케이스)</code></pre>

<h3>재귀 호출 스택 시각화</h3>

<pre><code>스택 레벨 0: quickSort([38, 27, 43, 3, 9, 82, 10])
├─ 스택 레벨 1: quickSort([]) → [] (빈 배열)
├─ 스택 레벨 1: quickSort([38, 27, 43, 9, 82, 10])
│  ├─ 스택 레벨 2: quickSort([38, 27, 9, 10])
│  │  ├─ 스택 레벨 3: quickSort([9]) → [9]
│  │  └─ 스택 레벨 3: quickSort([38, 27, 10])
│  │     ├─ 스택 레벨 4: quickSort([10]) → [10]
│  │     └─ 스택 레벨 4: quickSort([38]) → [38]
│  │     └─ 합쳐짐: [10, 27, 38]
│  └─ 스택 레벨 2: quickSort([82]) → [82]
│  └─ 합쳐짐: [9, 10, 27, 38, 43, 82]
└─ 합쳐짐: [] + 3 + [9, 10, 27, 38, 43, 82] = [3, 9, 10, 27, 38, 43, 82]</code></pre>

<h3>합쳐지는 과정 (병합 단계)</h3>

<p>각 재귀 호출이 완료되면 다음과 같이 합쳐집니다:</p>

<ol>
<li><strong>가장 깊은 레벨에서 시작</strong>:</li>
<li><code>[9]</code> + <code>[10, 27, 38]</code> = <code>[9, 10, 27, 38]</code></li>
</ol>

<ol>
<li><strong>한 단계 위로</strong>:</li>
<li><code>[9, 10, 27, 38]</code> + <code>43</code> + <code>[82]</code> = <code>[9, 10, 27, 38, 43, 82]</code></li>
</ol>

<ol>
<li><strong>최상위 레벨</strong>:</li>
<li><code>[]</code> + <code>3</code> + <code>[9, 10, 27, 38, 43, 82]</code> = <code>[3, 9, 10, 27, 38, 43, 82]</code></li>
</ol>

<h3>재귀의 핵심 원리</h3>

<ol>
<li><strong>분할</strong>: 배열을 피벗 기준으로 두 부분으로 나눔</li>
<li><strong>정복</strong>: 각 부분을 재귀적으로 정렬</li>
<li><strong>결합</strong>: 정렬된 부분들을 피벗과 함께 합침</li>
</ol>

<h3>스택 메모리 사용</h3>

<pre><code>호출 스택:
┌─────────────────────────────────────┐
│ quickSort([38, 27, 43, 3, 9, 82, 10]) │ ← 최상위
├─────────────────────────────────────┤
│ quickSort([38, 27, 43, 9, 82, 10])    │
├─────────────────────────────────────┤
│ quickSort([38, 27, 9, 10])           │
├─────────────────────────────────────┤
│ quickSort([38, 27, 10])              │
└─────────────────────────────────────┘</code></pre>

<p>각 재귀 호출은 독립적인 스택 프레임을 가지며, 완료되면 결과를 상위 호출자에게 반환합니다.</p>

<h3>시간 복잡도</h3>

<ul>
<li><strong>평균 케이스</strong>: O(n log n)</li>
<li><strong>최악 케이스</strong>: O(n²) - 이미 정렬된 배열이나 모든 요소가 같은 경우</li>
<li><strong>최선 케이스</strong>: O(n log n) - 피벗이 항상 중간값인 경우</li>
</ul>

<h3>공간 복잡도</h3>

<ul>
<li><strong>평균 케이스</strong>: O(log n) - 재귀 호출 스택</li>
<li><strong>최악 케이스</strong>: O(n) - 불균형한 분할의 경우</li>
</ul>

<h3>장단점</h3>

<h4>장점</h4>
<ol>
<li><strong>평균적으로 빠름</strong>: 대부분의 경우 O(n log n) 성능</li>
<li><strong>제자리 정렬</strong>: 추가 메모리 사용량이 적음</li>
<li><strong>캐시 친화적</strong>: 지역성(locality)이 좋음</li>
<li><strong>병렬화 가능</strong>: 분할된 부분을 병렬로 처리 가능</li>
</ol>

<h4>단점</h4>
<ol>
<li><strong>불안정 정렬</strong>: 같은 값의 상대적 순서가 바뀔 수 있음</li>
<li><strong>최악 케이스</strong>: 이미 정렬된 배열에서 O(n²) 성능</li>
<li><strong>피벗 선택의 중요성</strong>: 잘못된 피벗 선택 시 성능 저하</li>
</ol>

<h3>최적화 방안</h3>

<ol>
<li><strong>피벗 선택 개선</strong></li>
<li>삼중 중간값(median-of-three) 방법</li>
<li>랜덤 피벗 선택</li>
</ol>

<ol>
<li><strong>작은 배열 처리</strong></li>
<li>작은 배열(예: 10개 이하)은 삽입 정렬 사용</li>
</ol>

<ol>
<li><strong>중복 요소 처리</strong></li>
<li>피벗과 같은 요소들을 별도로 처리</li>
</ol>

<h3>사용법</h3>

<pre><code>import { quickSort, arr } from './QuickSort';

console.log('원본 배열:', arr);
const sortedArr = quickSort(arr);
console.log('정렬된 배열:', sortedArr);</code></pre>

<h3>다른 정렬 알고리즘과의 비교</h3>

<table>
<thead>
<tr>
<th>알고리즘</th>
<th>평균 시간</th>
<th>최악 시간</th>
<th>공간 복잡도</th>
<th>안정성</th>
</tr>
</thead>
<tbody>
<tr>
<td>퀵 정렬</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>불안정</td>
</tr>
<tr>
<td>병합 정렬</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>안정</td>
</tr>
<tr>
<td>힙 정렬</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>불안정</td>
</tr>
<tr>
<td>삽입 정렬</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>안정</td>
</tr>
</tbody>
</table>
    </div>
</body>
</html>